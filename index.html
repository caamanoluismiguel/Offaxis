<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="theme-color" content="#0e0f14">
    <meta name="description" content="OffAxis 3D: head-tracked and hand-gesture driven 3D object viewer with real-time editing.">
    <title>OffAxis 3D</title>

    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@500;700&family=Manrope:wght@400;600;700&display=swap" rel="stylesheet">

    <style>
        :root {
            --bg: #0e0f14;
            --bg-soft: #1a1d27;
            --primary: #ff6a00;
            --primary-dim: rgba(255, 106, 0, 0.33);
            --accent: #00e8d3;
            --success: #22e08a;
            --danger: #ff4c68;
            --text: #f7f9ff;
            --text-dim: #96a0b5;
            --panel: rgba(12, 15, 24, 0.78);
            --border: rgba(255, 255, 255, 0.12);
            --shadow: 0 16px 48px rgba(0, 0, 0, 0.45);
            --panel-blur: blur(18px);
        }

        * { margin: 0; padding: 0; box-sizing: border-box; }

        html, body {
            width: 100%;
            height: 100%;
        }

        body {
            background:
                radial-gradient(1200px 500px at 5% -10%, rgba(0, 232, 211, 0.08), transparent 70%),
                radial-gradient(900px 450px at 95% 110%, rgba(255, 106, 0, 0.11), transparent 70%),
                linear-gradient(165deg, #090a0f 0%, #111420 45%, #0e0f14 100%);
            overflow: hidden;
            font-family: "Manrope", system-ui, sans-serif;
            touch-action: none;
            color: var(--text);
        }

        body::before,
        body::after {
            content: "";
            position: fixed;
            pointer-events: none;
            z-index: 0;
        }

        body::before {
            width: 36vw;
            height: 36vw;
            max-width: 460px;
            max-height: 460px;
            right: -12vw;
            top: -14vw;
            background: radial-gradient(circle, rgba(255, 106, 0, 0.2) 0%, transparent 70%);
            filter: blur(20px);
        }

        body::after {
            width: 30vw;
            height: 30vw;
            max-width: 400px;
            max-height: 400px;
            left: -10vw;
            bottom: -10vw;
            background: radial-gradient(circle, rgba(0, 232, 211, 0.18) 0%, transparent 72%);
            filter: blur(16px);
        }

        #canvas3d {
            width: 100vw;
            height: 100vh;
            display: block;
            position: relative;
            z-index: 1;
        }

        .panel {
            background: var(--panel);
            border: 1px solid var(--border);
            backdrop-filter: var(--panel-blur);
            box-shadow: var(--shadow);
        }

        .lift {
            animation: panelIn 0.45s ease-out;
        }

        @keyframes panelIn {
            from { opacity: 0; transform: translateY(10px) scale(0.98); }
            to { opacity: 1; transform: translateY(0) scale(1); }
        }

        /* ===== PIP Camera ===== */
        #pip {
            position: fixed;
            bottom: 24px;
            right: 24px;
            width: 138px;
            height: 98px;
            border-radius: 16px;
            overflow: hidden;
            z-index: 100;
            border: 2px solid var(--primary-dim);
            transition: transform 0.24s ease, border-color 0.24s ease, box-shadow 0.24s ease;
        }

        #pip:hover { transform: scale(1.03); }

        #pip.edit-mode {
            border-color: color-mix(in srgb, var(--success) 75%, white 25%);
            box-shadow: 0 8px 36px rgba(34, 224, 138, 0.22);
        }

        #pip video {
            width: 100%;
            height: 100%;
            object-fit: cover;
            transform: scaleX(-1);
        }

        #pip canvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
        }

        #pip .status {
            position: absolute;
            bottom: 6px;
            left: 50%;
            transform: translateX(-50%);
            font-size: 9px;
            font-weight: 700;
            padding: 2px 8px;
            border-radius: 8px;
            background: rgba(0, 0, 0, 0.65);
            color: var(--success);
            text-transform: uppercase;
            letter-spacing: 0.7px;
        }

        #pip .status.off { color: var(--danger); }

        #pip .rec {
            position: absolute;
            top: 8px;
            left: 8px;
            width: 8px;
            height: 8px;
            border-radius: 50%;
            background: var(--danger);
            opacity: 0.5;
        }

        #pip .rec.on {
            opacity: 1;
            animation: pulse 1s infinite;
        }

        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.35; }
        }

        /* ===== Object Selector ===== */
        #objectSelector {
            position: fixed;
            bottom: 24px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            gap: 5px;
            padding: 7px;
            border-radius: 28px;
            z-index: 120;
            transition: opacity 0.24s ease, transform 0.24s ease;
        }

        #objectSelector.hidden {
            opacity: 0;
            pointer-events: none;
            transform: translateX(-50%) translateY(18px);
        }

        .obj-btn {
            width: 48px;
            height: 48px;
            border-radius: 24px;
            border: none;
            background: transparent;
            color: var(--text-dim);
            font-size: 11px;
            font-weight: 700;
            cursor: pointer;
            transition: all 0.16s ease;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            gap: 2px;
            font-family: "Manrope", sans-serif;
        }

        .obj-btn .icon {
            font-size: 17px;
            line-height: 1;
        }

        .obj-btn:hover {
            color: var(--text);
            background: rgba(255, 255, 255, 0.07);
        }

        .obj-btn.active {
            background: linear-gradient(140deg, #ff7f2c, #ff5a00);
            color: white;
            box-shadow: 0 6px 18px var(--primary-dim);
        }

        .obj-btn.upload {
            border: 2px dashed var(--border);
            background: transparent;
        }

        .obj-btn.upload:hover {
            border-color: var(--primary);
            color: var(--primary);
        }

        /* ===== Mode Toggle ===== */
        #modeToggle {
            position: fixed;
            bottom: 92px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            border-radius: 25px;
            padding: 4px;
            z-index: 200;
        }

        .mode-btn {
            padding: 10px 24px;
            border: none;
            border-radius: 21px;
            background: transparent;
            color: var(--text-dim);
            font-size: 13px;
            font-weight: 700;
            cursor: pointer;
            transition: all 0.2s ease;
            display: flex;
            align-items: center;
            gap: 6px;
            font-family: "Orbitron", sans-serif;
            letter-spacing: 0.4px;
        }

        .mode-btn .icon { font-size: 15px; }

        .mode-btn.active {
            background: var(--primary);
            color: white;
            box-shadow: 0 4px 16px var(--primary-dim);
        }

        .mode-btn.active.edit {
            background: linear-gradient(140deg, #18b66e, #20dd88);
            box-shadow: 0 4px 16px rgba(34, 224, 138, 0.34);
        }

        /* ===== Gesture Status ===== */
        #gestureStatus {
            position: fixed;
            bottom: 154px;
            left: 50%;
            transform: translateX(-50%);
            border: 2px solid var(--border);
            border-radius: 24px;
            padding: 10px 20px;
            z-index: 160;
            display: none;
            align-items: center;
            gap: 10px;
            min-width: 168px;
            justify-content: center;
            transition: border-color 0.2s ease;
            overflow: hidden;
        }

        #gestureStatus.show { display: flex; }
        #gestureStatus.scale { border-color: var(--success); }
        #gestureStatus.rotate { border-color: var(--primary); }
        #gestureStatus.reset { border-color: var(--danger); }

        #gestureStatus .icon { font-size: 18px; }
        #gestureStatus .text { font-size: 13px; font-weight: 700; }

        #gestureStatus .progress {
            position: absolute;
            bottom: 0;
            left: 12px;
            right: 12px;
            height: 3px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 2px;
            overflow: hidden;
        }

        #gestureStatus .progress::after {
            content: "";
            position: absolute;
            left: 0;
            top: 0;
            height: 100%;
            width: var(--progress, 0%);
            background: linear-gradient(90deg, #ff5f7a, #ff99aa);
            transition: width 0.1s;
        }

        /* ===== Model Info ===== */
        #modelInfo {
            position: fixed;
            top: 24px;
            left: 50%;
            transform: translateX(-50%);
            padding: 10px 20px;
            border-radius: 20px;
            font-size: 12px;
            z-index: 100;
            display: none;
            align-items: center;
            gap: 10px;
        }

        #modelInfo.show { display: flex; }

        #modelInfo .icon {
            font-size: 15px;
            filter: drop-shadow(0 2px 8px rgba(255, 106, 0, 0.4));
        }

        #modelInfo .name {
            color: var(--primary);
            font-weight: 700;
            max-width: 170px;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
        }

        #modelInfo .meta {
            color: var(--text-dim);
            font-size: 11px;
        }

        #modelInfo .close {
            background: none;
            border: none;
            color: var(--text-dim);
            font-size: 16px;
            cursor: pointer;
            padding: 4px;
            margin-left: 4px;
        }

        #modelInfo .close:hover,
        #modelInfo .close:focus-visible { color: var(--text); }

        /* ===== Debug ===== */
        #debugPanel {
            position: fixed;
            top: 24px;
            right: 24px;
            border-radius: 12px;
            padding: 12px;
            font-size: 10px;
            font-family: "SF Mono", "Menlo", monospace;
            z-index: 100;
            min-width: 150px;
            transition: all 0.24s ease;
            opacity: 0;
            pointer-events: none;
            transform: translateY(-10px);
        }

        #debugPanel.show {
            opacity: 1;
            pointer-events: auto;
            transform: translateY(0);
        }

        #debugPanel .row {
            display: flex;
            justify-content: space-between;
            padding: 4px 0;
            border-bottom: 1px solid var(--border);
        }

        #debugPanel .row:last-child { border-bottom: none; }
        #debugPanel .label { color: var(--text-dim); }
        #debugPanel .value { color: var(--primary); font-weight: 700; }
        #debugPanel .value.ok { color: var(--success); }
        #debugPanel .value.err { color: var(--danger); }

        #debugToggle {
            position: fixed;
            top: 24px;
            right: 24px;
            width: 38px;
            height: 38px;
            border-radius: 20px;
            border: 1px solid var(--border);
            background: var(--panel);
            color: var(--text-dim);
            font-size: 14px;
            cursor: pointer;
            z-index: 101;
            backdrop-filter: var(--panel-blur);
            transition: all 0.2s ease;
        }

        #debugToggle:hover,
        #debugToggle:focus-visible {
            color: var(--text);
            border-color: var(--primary);
        }

        #debugToggle.active {
            right: 194px;
            color: var(--primary);
        }

        /* ===== Gesture Help ===== */
        #gestureHelp {
            position: fixed;
            inset: 0;
            background: rgba(4, 5, 10, 0.9);
            display: none;
            align-items: center;
            justify-content: center;
            z-index: 600;
            backdrop-filter: blur(10px);
        }

        #gestureHelp.show { display: flex; }

        #gestureHelp .content {
            border-radius: 24px;
            padding: 30px;
            text-align: center;
            max-width: 360px;
            width: calc(100% - 32px);
        }

        #gestureHelp h3 {
            font-family: "Orbitron", sans-serif;
            letter-spacing: 0.6px;
            font-size: 20px;
            margin-bottom: 20px;
        }

        #gestureHelp .gesture-row {
            display: flex;
            align-items: center;
            gap: 14px;
            padding: 11px 0;
            border-bottom: 1px solid var(--border);
            font-size: 14px;
        }

        #gestureHelp .gesture-row:last-of-type { border-bottom: none; }
        #gestureHelp .gesture-row .icon { font-size: 27px; width: 50px; }
        #gestureHelp .gesture-row .desc { text-align: left; color: var(--text-dim); }

        #gestureHelp button {
            margin-top: 22px;
            background: var(--primary);
            border: none;
            border-radius: 20px;
            padding: 12px 32px;
            color: white;
            font-size: 14px;
            font-weight: 700;
            cursor: pointer;
        }

        #helpBtn {
            position: fixed;
            bottom: 24px;
            left: 24px;
            width: 42px;
            height: 42px;
            border-radius: 21px;
            border: 1px solid var(--border);
            background: var(--panel);
            color: var(--text-dim);
            font-size: 15px;
            font-weight: 700;
            cursor: pointer;
            z-index: 150;
            display: none;
            backdrop-filter: var(--panel-blur);
        }

        #helpBtn.show { display: flex; align-items: center; justify-content: center; }

        #helpBtn:hover,
        #helpBtn:focus-visible { color: var(--text); border-color: var(--success); }

        /* ===== Toast ===== */
        #toast {
            position: fixed;
            left: 50%;
            top: 76px;
            transform: translateX(-50%) translateY(-8px);
            opacity: 0;
            pointer-events: none;
            z-index: 320;
            font-size: 12px;
            font-weight: 700;
            padding: 10px 14px;
            border-radius: 14px;
            transition: opacity 0.24s ease, transform 0.24s ease;
        }

        #toast.show {
            opacity: 1;
            transform: translateX(-50%) translateY(0);
        }

        /* ===== Loading ===== */
        #loading {
            position: fixed;
            inset: 0;
            background: rgba(8, 9, 13, 0.93);
            display: none;
            align-items: center;
            justify-content: center;
            flex-direction: column;
            z-index: 500;
        }

        #loading.show { display: flex; }

        .spinner {
            width: 40px;
            height: 40px;
            border: 3px solid var(--border);
            border-top-color: var(--primary);
            border-radius: 50%;
            animation: spin 0.8s linear infinite;
        }

        @keyframes spin { to { transform: rotate(360deg); } }

        #loading p {
            color: var(--text-dim);
            margin-top: 14px;
            font-size: 14px;
        }

        #fileInput { display: none; }

        button:focus-visible {
            outline: 2px solid rgba(0, 232, 211, 0.8);
            outline-offset: 2px;
        }

        @media (max-width: 760px) {
            #pip {
                width: 112px;
                height: 84px;
                bottom: 14px;
                right: 14px;
            }

            #modeToggle {
                bottom: 86px;
            }

            .mode-btn {
                padding: 9px 16px;
                font-size: 12px;
            }

            #objectSelector {
                bottom: 14px;
                gap: 3px;
                padding: 6px;
            }

            .obj-btn {
                width: 42px;
                height: 42px;
                font-size: 10px;
            }

            #gestureStatus {
                bottom: 138px;
            }

            #helpBtn {
                left: 14px;
                bottom: 14px;
            }

            #debugToggle {
                top: 12px;
                right: 12px;
            }

            #debugPanel {
                top: 12px;
                right: 12px;
            }

            #modelInfo {
                top: 12px;
            }
        }

        @media (prefers-reduced-motion: reduce) {
            *, *::before, *::after {
                animation-duration: 0.001ms !important;
                animation-iteration-count: 1 !important;
                transition-duration: 0.001ms !important;
                scroll-behavior: auto !important;
            }
        }
    </style>
</head>
<body>
    <canvas id="canvas3d" aria-label="3D scene"></canvas>

    <div id="pip" class="panel lift" aria-label="Camera preview">
        <video id="vid" playsinline autoplay muted></video>
        <canvas id="ovr" aria-hidden="true"></canvas>
        <div class="rec" id="rec"></div>
        <div class="status" id="pipStatus">READY</div>
    </div>

    <div id="objectSelector" class="panel lift" role="toolbar" aria-label="Object selector">
        <button class="obj-btn active" data-obj="cube" aria-label="Show cube object">
            <span class="icon">‚ñ£</span>
            <span>Cube</span>
        </button>
        <button class="obj-btn" data-obj="torus" aria-label="Show knot object">
            <span class="icon">‚óé</span>
            <span>Knot</span>
        </button>
        <button class="obj-btn" data-obj="gem" aria-label="Show gem object">
            <span class="icon">‚óá</span>
            <span>Gem</span>
        </button>
        <button class="obj-btn" data-obj="tesseract" aria-label="Show tesseract object">
            <span class="icon">‚¨¢</span>
            <span>Hyper</span>
        </button>
        <button class="obj-btn upload" id="uploadBtn" aria-label="Upload STL or OBJ model">
            <span class="icon">+</span>
        </button>
    </div>
    <input type="file" id="fileInput" accept=".stl,.STL,.obj,.OBJ" aria-label="Upload model file">

    <div id="modeToggle" class="panel lift" role="group" aria-label="Interaction mode">
        <button class="mode-btn active" data-mode="view" aria-label="Switch to view mode">
            <span class="icon">üëÅ</span>
            <span>View</span>
        </button>
        <button class="mode-btn" data-mode="edit" aria-label="Switch to edit mode">
            <span class="icon">‚úã</span>
            <span>Edit</span>
        </button>
    </div>

    <div id="gestureStatus" class="panel" role="status" aria-live="polite">
        <span class="icon">üëã</span>
        <span class="text">Show hands</span>
        <div class="progress"></div>
    </div>

    <div id="modelInfo" class="panel" role="status" aria-live="polite">
        <span class="icon">üì¶</span>
        <span class="name" id="modelName"></span>
        <span class="meta" id="modelMeta"></span>
        <button class="close" id="clearModel" aria-label="Clear uploaded model">‚úï</button>
    </div>

    <button id="debugToggle" aria-label="Toggle debug panel">‚öô</button>

    <div id="debugPanel" class="panel" aria-live="polite">
        <div class="row"><span class="label">Mode</span><span class="value" id="dMode">VIEW</span></div>
        <div class="row"><span class="label">Camera</span><span class="value" id="dCam">--</span></div>
        <div class="row"><span class="label">Track</span><span class="value" id="dTrack">--</span></div>
        <div class="row"><span class="label">Hands</span><span class="value" id="dHands">0</span></div>
        <div class="row"><span class="label">FPS</span><span class="value" id="dFPS">--</span></div>
    </div>

    <div id="gestureHelp" aria-modal="true" role="dialog" aria-label="Gesture help">
        <div class="content panel">
            <h3>Hand Gestures</h3>
            <div class="gesture-row">
                <span class="icon">‚úä</span>
                <span class="desc">Fist or pinch plus drag to rotate</span>
            </div>
            <div class="gesture-row">
                <span class="icon">üëåüëå</span>
                <span class="desc">Two pinches, spread to scale</span>
            </div>
            <div class="gesture-row">
                <span class="icon">‚úã‚úã</span>
                <span class="desc">Both open, hold 2s to reset</span>
            </div>
            <button id="closeHelp" aria-label="Close gesture help">Got it</button>
        </div>
    </div>

    <button id="helpBtn" aria-label="Open gesture help">?</button>

    <div id="toast" class="panel" role="status" aria-live="polite"></div>

    <div id="loading">
        <div class="spinner"></div>
        <p id="loadTxt">Loading...</p>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/face_detection/face_detection.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js" crossorigin="anonymous"></script>

    <script>
    (function() {
        "use strict";

        const $ = id => document.getElementById(id);
        const clamp = (v, min, max) => Math.max(min, Math.min(max, v));
        const prefersReducedMotion = window.matchMedia("(prefers-reduced-motion: reduce)").matches;

        function log(msg, type = "") {
            console.log("[" + (type || "i") + "] " + msg);
        }

        function setDebug(id, val, status = "") {
            const el = $(id);
            if (!el) return;
            el.textContent = val;
            el.className = "value " + status;
        }

        let frameCount = 0;
        let lastFpsTime = performance.now();

        function updateFPS() {
            frameCount += 1;
            const now = performance.now();
            if (now - lastFpsTime >= 1000) {
                setDebug("dFPS", frameCount);
                frameCount = 0;
                lastFpsTime = now;
            }
        }

        function parseSTL(buffer) {
            const isBinary = data => {
                const reader = new DataView(data);
                if (reader.byteLength < 84) return false;
                const faceSize = (32 / 8 * 3) + ((32 / 8 * 3) * 3) + (16 / 8);
                const nFaces = reader.getUint32(80, true);
                const expect = 80 + (32 / 8) + (nFaces * faceSize);
                if (expect === reader.byteLength) return true;
                const solid = [115, 111, 108, 105, 100];
                for (let i = 0; i < 5; i++) {
                    if (solid[i] !== reader.getUint8(i)) return true;
                }
                return false;
            };

            const parseBinary = data => {
                const reader = new DataView(data);
                const faces = reader.getUint32(80, true);
                const vertices = new Float32Array(faces * 9);
                const normals = new Float32Array(faces * 9);
                const dataOffset = 84;
                const faceLength = 50;

                for (let face = 0; face < faces; face++) {
                    const start = dataOffset + face * faceLength;
                    const nx = reader.getFloat32(start, true);
                    const ny = reader.getFloat32(start + 4, true);
                    const nz = reader.getFloat32(start + 8, true);

                    for (let i = 1; i <= 3; i++) {
                        const idx = (face * 9) + ((i - 1) * 3);
                        vertices[idx] = reader.getFloat32(start + i * 12, true);
                        vertices[idx + 1] = reader.getFloat32(start + i * 12 + 4, true);
                        vertices[idx + 2] = reader.getFloat32(start + i * 12 + 8, true);
                        normals[idx] = nx;
                        normals[idx + 1] = ny;
                        normals[idx + 2] = nz;
                    }
                }

                const geo = new THREE.BufferGeometry();
                geo.setAttribute("position", new THREE.BufferAttribute(vertices, 3));
                geo.setAttribute("normal", new THREE.BufferAttribute(normals, 3));
                return geo;
            };

            const parseASCII = text => {
                const vertices = [];
                const normals = [];
                let currentNormal = [0, 0, 1];

                text.split("\n").forEach(line => {
                    const parts = line.trim().split(/\s+/);
                    if (parts[0] === "facet" && parts[1] === "normal") {
                        currentNormal = [parseFloat(parts[2]), parseFloat(parts[3]), parseFloat(parts[4])];
                    } else if (parts[0] === "vertex") {
                        vertices.push(parseFloat(parts[1]), parseFloat(parts[2]), parseFloat(parts[3]));
                        normals.push(currentNormal[0], currentNormal[1], currentNormal[2]);
                    }
                });

                const geo = new THREE.BufferGeometry();
                geo.setAttribute("position", new THREE.Float32BufferAttribute(vertices, 3));
                geo.setAttribute("normal", new THREE.Float32BufferAttribute(normals, 3));
                return geo;
            };

            return isBinary(buffer)
                ? parseBinary(buffer)
                : parseASCII(new TextDecoder().decode(buffer));
        }

        function parseOBJ(text) {
            const vertices = [];
            const normals = [];
            const outPos = [];
            const outNorm = [];

            text.split("\n").forEach(line => {
                const parts = line.trim().split(/\s+/);
                if (parts[0] === "v") vertices.push([+parts[1], +parts[2], +parts[3]]);
                else if (parts[0] === "vn") normals.push([+parts[1], +parts[2], +parts[3]]);
            });

            text.split("\n").forEach(line => {
                const parts = line.trim().split(/\s+/);
                if (parts[0] !== "f") return;

                const fv = [];
                for (let i = 1; i < parts.length; i++) {
                    const p = parts[i].split("/");
                    let vi = parseInt(p[0], 10) || 0;
                    let ni = parseInt(p[2], 10) || 0;
                    if (vi < 0) vi = vertices.length + vi + 1;
                    if (ni < 0) ni = normals.length + ni + 1;
                    fv.push({ v: vi - 1, n: ni - 1 });
                }

                for (let i = 1; i < fv.length - 1; i++) {
                    [fv[0], fv[i], fv[i + 1]].forEach(f => {
                        const v = vertices[f.v] || [0, 0, 0];
                        outPos.push(v[0], v[1], v[2]);
                        if (f.n >= 0 && normals[f.n]) {
                            outNorm.push(normals[f.n][0], normals[f.n][1], normals[f.n][2]);
                        } else {
                            outNorm.push(0, 1, 0);
                        }
                    });
                }
            });

            const geo = new THREE.BufferGeometry();
            geo.setAttribute("position", new THREE.Float32BufferAttribute(outPos, 3));
            geo.setAttribute("normal", new THREE.Float32BufferAttribute(outNorm, 3));
            return geo;
        }

        class Tesseract {
            constructor() {
                this.group = new THREE.Group();
                this.vertices4D = [];
                this.rotationXW = 0;
                this.rotationYW = 0;
                this.rotationZW = 0;
                this.scale3D = 60;

                for (let i = 0; i < 16; i++) {
                    this.vertices4D.push([
                        (i & 1) ? 1 : -1,
                        (i & 2) ? 1 : -1,
                        (i & 4) ? 1 : -1,
                        (i & 8) ? 1 : -1
                    ]);
                }

                this.edges = [];
                for (let i = 0; i < 16; i++) {
                    for (let j = i + 1; j < 16; j++) {
                        let diff = 0;
                        for (let k = 0; k < 4; k++) {
                            if (this.vertices4D[i][k] !== this.vertices4D[j][k]) diff += 1;
                        }
                        if (diff === 1) this.edges.push([i, j]);
                    }
                }

                this.lines = [];
                this.edges.forEach(() => {
                    const geo = new THREE.BufferGeometry();
                    geo.setAttribute("position", new THREE.Float32BufferAttribute([0, 0, 0, 0, 0, 0], 3));
                    const mat = new THREE.LineBasicMaterial({
                        color: 0xff6a00,
                        transparent: true,
                        opacity: 0.8
                    });
                    const line = new THREE.Line(geo, mat);
                    this.lines.push(line);
                    this.group.add(line);
                });

                this.dots = [];
                for (let i = 0; i < 16; i++) {
                    const dot = new THREE.Mesh(
                        new THREE.SphereGeometry(2.5, 8, 8),
                        new THREE.MeshBasicMaterial({ color: 0x00e8d3 })
                    );
                    this.dots.push(dot);
                    this.group.add(dot);
                }

                this.group.position.z = -80;
            }

            project4Dto3D(v4, rotXW, rotYW, rotZW) {
                let x = v4[0];
                let y = v4[1];
                let z = v4[2];
                let w = v4[3];

                const cosXW = Math.cos(rotXW);
                const sinXW = Math.sin(rotXW);
                const x2 = x * cosXW - w * sinXW;
                const w2 = x * sinXW + w * cosXW;
                x = x2;
                w = w2;

                const cosYW = Math.cos(rotYW);
                const sinYW = Math.sin(rotYW);
                const y2 = y * cosYW - w * sinYW;
                const w3 = y * sinYW + w * cosYW;
                y = y2;
                w = w3;

                const cosZW = Math.cos(rotZW);
                const sinZW = Math.sin(rotZW);
                const z2 = z * cosZW - w * sinZW;
                const w4 = z * sinZW + w * cosZW;
                z = z2;
                w = w4;

                const distance = 2.5;
                const wClamped = clamp(w, -1.5, 1.5);
                const perspScale = distance / (distance - wClamped);

                return {
                    x: x * perspScale * this.scale3D,
                    y: y * perspScale * this.scale3D,
                    z: z * perspScale * this.scale3D,
                    w: wClamped
                };
            }

            update(dt) {
                this.rotationXW += dt * 0.4;
                this.rotationYW += dt * 0.25;
                this.rotationZW += dt * 0.15;

                const projected = this.vertices4D.map(v => this.project4Dto3D(v, this.rotationXW, this.rotationYW, this.rotationZW));

                projected.forEach((p, i) => {
                    this.dots[i].position.set(p.x, p.y, p.z);
                    const s = 0.6 + (p.w + 1.5) * 0.3;
                    this.dots[i].scale.setScalar(clamp(s, 0.3, 1.5));
                });

                this.edges.forEach((edge, i) => {
                    const pa = projected[edge[0]];
                    const pb = projected[edge[1]];
                    const positions = this.lines[i].geometry.attributes.position.array;
                    positions[0] = pa.x;
                    positions[1] = pa.y;
                    positions[2] = pa.z;
                    positions[3] = pb.x;
                    positions[4] = pb.y;
                    positions[5] = pb.z;
                    this.lines[i].geometry.attributes.position.needsUpdate = true;

                    const avgW = (pa.w + pb.w) / 2;
                    this.lines[i].material.opacity = 0.3 + (avgW + 1.5) * 0.25;
                });
            }
        }

        class HandController {
            constructor(app) {
                this.app = app;
                this.hands = null;
                this.ready = false;
                this.active = false;

                this.state = "IDLE";
                this.stateStartTime = 0;

                this.handData = [null, null];
                this.handsDetected = 0;

                this.stableState = "IDLE";
                this.stableStateStart = 0;
                this.requiredStableTimes = {
                    IDLE: 120,
                    TRACKING: 100,
                    FIST_ROTATE: 70,
                    TWO_HAND_TRACKING: 100,
                    TWO_HAND_SCALE: 90,
                    TWO_HAND_EXIT: 250
                };

                this.handCenter = { x: 0.5, y: 0.5 };
                this.prevHandCenter = { x: 0.5, y: 0.5 };
                this.rotVel = { x: 0, y: 0 };

                this.scaleStartDistance = 0;
                this.scaleStartValue = 1;
                this.twoHandOpenStart = 0;
                this.hasShownHint = false;

                this.lastDetectionAt = 0;
                this.detectIntervalMs = 33;

                this.statusEl = $("gestureStatus");
                this.statusIcon = this.statusEl.querySelector(".icon");
                this.statusText = this.statusEl.querySelector(".text");
                this.progressEl = this.statusEl.querySelector(".progress");
            }

            async init() {
                if (typeof Hands === "undefined") {
                    log("MediaPipe Hands not available", "e");
                    return false;
                }

                try {
                    this.hands = new Hands({
                        locateFile: f => "https://cdn.jsdelivr.net/npm/@mediapipe/hands/" + f
                    });

                    this.hands.setOptions({
                        maxNumHands: 2,
                        modelComplexity: 1,
                        minDetectionConfidence: 0.6,
                        minTrackingConfidence: 0.55
                    });

                    this.hands.onResults(r => this.onResults(r));
                    this.ready = true;
                    log("Hand tracking ready", "ok");
                    return true;
                } catch (err) {
                    log("Hand init failed: " + err.message, "e");
                    return false;
                }
            }

            start() {
                if (!this.ready) return;

                this.active = true;
                this.state = "IDLE";
                this.stableState = "IDLE";
                this.stableStateStart = Date.now();
                this.rotVel = { x: 0, y: 0 };
                this.showStatus("üëã", "Show hands");
                this.statusEl.classList.add("show");
                $("helpBtn").classList.add("show");

                if (!this.hasShownHint) {
                    this.hasShownHint = true;
                    setTimeout(() => {
                        if (this.active && this.state === "IDLE") {
                            $("gestureHelp").classList.add("show");
                        }
                    }, 2500);
                }

                this.runDetection();
            }

            stop() {
                this.active = false;
                this.state = "IDLE";
                this.handData = [null, null];
                this.rotVel = { x: 0, y: 0 };
                this.statusEl.classList.remove("show", "scale", "rotate", "reset");
                $("helpBtn").classList.remove("show");
            }

            runDetection() {
                if (!this.active || !this.hands || !this.app.vid) return;

                const detect = async () => {
                    if (!this.active) return;

                    const now = performance.now();
                    if (this.app.vid.readyState >= 2 && now - this.lastDetectionAt >= this.detectIntervalMs) {
                        this.lastDetectionAt = now;
                        try {
                            await this.hands.send({ image: this.app.vid });
                        } catch (e) {
                            // Ignore intermittent inference errors.
                        }
                    }

                    if (this.active) requestAnimationFrame(detect);
                };

                detect();
            }

            onResults(results) {
                if (!this.active) return;

                const ctx = this.app.ctx;
                const ovr = this.app.ovr;
                if (ctx) ctx.clearRect(0, 0, ovr.width, ovr.height);

                this.handsDetected = results.multiHandLandmarks ? results.multiHandLandmarks.length : 0;
                setDebug("dHands", this.handsDetected);
                this.handData = [null, null];

                if (this.handsDetected === 0) {
                    this.handleNoHands();
                    return;
                }

                for (let i = 0; i < this.handsDetected; i++) {
                    this.handData[i] = this.analyzeHand(results.multiHandLandmarks[i]);
                }

                if (this.handsDetected === 2 && this.handData[0] && this.handData[1]) {
                    if (this.handData[0].centerX > this.handData[1].centerX) {
                        const temp = this.handData[0];
                        this.handData[0] = this.handData[1];
                        this.handData[1] = temp;
                    }
                }

                this.drawHands(ctx, ovr);
                const gesture = this.detectGesture();
                this.applyStability(gesture);
                this.executeAction();
            }

            analyzeHand(landmarks) {
                if (!landmarks || landmarks.length < 21) return null;
                const lm = landmarks;

                const dist = (a, b) => Math.hypot(lm[a].x - lm[b].x, lm[a].y - lm[b].y);

                let cx = 0;
                let cy = 0;
                [0, 5, 9, 13, 17].forEach(i => {
                    cx += lm[i].x;
                    cy += lm[i].y;
                });
                cx /= 5;
                cy /= 5;

                const tips = [8, 12, 16, 20];
                const pips = [6, 10, 14, 18];
                const mcps = [5, 9, 13, 17];

                let curledCount = 0;
                let extendedCount = 0;

                for (let i = 0; i < 4; i++) {
                    const tipToWrist = dist(tips[i], 0);
                    const pipToWrist = dist(pips[i], 0);
                    const mcpToWrist = dist(mcps[i], 0) || 0.0001;
                    const ratio = tipToWrist / mcpToWrist;

                    if (ratio > 1.03 && tipToWrist > pipToWrist) extendedCount += 1;
                    if (ratio < 0.83 || tipToWrist < pipToWrist * 0.95) curledCount += 1;
                }

                const pinchDist = dist(4, 8);
                const pinchPoint = {
                    x: (lm[4].x + lm[8].x) / 2,
                    y: (lm[4].y + lm[8].y) / 2
                };

                const thumbToPalm = dist(4, 0);
                const indexBaseToPalm = dist(5, 0) || 0.0001;
                const thumbFolded = thumbToPalm < indexBaseToPalm * 0.95;

                const palmWidth = dist(5, 17) || 0.0001;
                const pinchNormalized = pinchDist / palmWidth;
                const pinchConfidence = clamp((0.5 - pinchNormalized) / 0.26, 0, 1);

                const isPinching = pinchNormalized < 0.35;
                const openScore = extendedCount / 4;
                const isOpen = openScore >= 0.72 && !isPinching;

                const fistScore = clamp((curledCount / 4) * 0.85 + (thumbFolded ? 0.15 : 0), 0, 1);
                const isFist = fistScore >= 0.7 && !isPinching;

                const rotateCandidate = isFist || pinchConfidence > 0.78;
                const motionPoint = isPinching ? pinchPoint : { x: cx, y: cy };

                return {
                    landmarks: lm,
                    centerX: cx,
                    centerY: cy,
                    motionPoint,
                    isPinching,
                    pinchPoint,
                    isOpen,
                    isFist,
                    rotateCandidate,
                    pinchConfidence,
                    fistScore
                };
            }

            detectGesture() {
                const h0 = this.handData[0];
                const h1 = this.handData[1];

                if (this.handsDetected === 2 && h0 && h1) {
                    if (h0.isOpen && h1.isOpen) return "TWO_HAND_EXIT";
                    if (h0.isPinching && h1.isPinching) return "TWO_HAND_SCALE";
                    return "TWO_HAND_TRACKING";
                }

                if (this.handsDetected === 1) {
                    const hand = h0 || h1;
                    if (!hand) return "IDLE";

                    this.prevHandCenter = { x: this.handCenter.x, y: this.handCenter.y };
                    this.handCenter = { x: hand.motionPoint.x, y: hand.motionPoint.y };

                    if (hand.rotateCandidate) return "FIST_ROTATE";
                    return "TRACKING";
                }

                return "IDLE";
            }

            applyStability(gesture) {
                const now = Date.now();
                if (gesture !== this.stableState) {
                    this.stableState = gesture;
                    this.stableStateStart = now;
                    return;
                }

                const required = this.requiredStableTimes[gesture] || 120;
                if (now - this.stableStateStart >= required && gesture !== this.state) {
                    this.enterState(gesture);
                }
            }

            enterState(newState) {
                this.state = newState;
                this.stateStartTime = Date.now();
                this.statusEl.classList.remove("scale", "rotate", "reset");
                this.progressEl.style.setProperty("--progress", "0%");

                switch (newState) {
                    case "IDLE":
                        this.showStatus("üëã", "Show hands");
                        break;
                    case "TRACKING":
                        this.showStatus("‚úã", "Tracking");
                        break;
                    case "FIST_ROTATE":
                        this.showStatus("‚úä", "Rotate hand");
                        this.statusEl.classList.add("rotate");
                        break;
                    case "TWO_HAND_SCALE":
                        this.enterScaleMode();
                        break;
                    case "TWO_HAND_TRACKING":
                        this.showStatus("‚úã‚úã", "Tracking");
                        break;
                    case "TWO_HAND_EXIT":
                        this.twoHandOpenStart = Date.now();
                        this.showStatus("‚úã‚úã", "Hold to reset");
                        this.statusEl.classList.add("reset");
                        break;
                    default:
                        break;
                }
            }

            enterScaleMode() {
                const h0 = this.handData[0];
                const h1 = this.handData[1];
                if (h0 && h1) {
                    const dx = h1.pinchPoint.x - h0.pinchPoint.x;
                    const dy = h1.pinchPoint.y - h0.pinchPoint.y;
                    this.scaleStartDistance = Math.hypot(dx, dy) || 0.3;
                    this.scaleStartValue = this.app.obj ? this.app.obj.scale.x : 1;
                }
                this.showStatus("üëåüëå", "Scale");
                this.statusEl.classList.add("scale");
            }

            handleNoHands() {
                if (this.state !== "IDLE" && Date.now() - this.stableStateStart > 240) {
                    this.enterState("IDLE");
                }
            }

            executeAction() {
                switch (this.state) {
                    case "FIST_ROTATE":
                        this.applyRotation();
                        break;
                    case "TWO_HAND_SCALE":
                        this.applyScale();
                        break;
                    case "TWO_HAND_EXIT":
                        this.checkReset();
                        break;
                    default:
                        break;
                }
            }

            applyRotation() {
                const hand = this.handData[0] || this.handData[1];
                if (!hand) return;

                const rawDx = this.handCenter.x - this.prevHandCenter.x;
                const rawDy = this.handCenter.y - this.prevHandCenter.y;

                this.rotVel.x = this.rotVel.x * 0.7 + rawDx * 0.3;
                this.rotVel.y = this.rotVel.y * 0.7 + rawDy * 0.3;

                if (Math.abs(this.rotVel.x) < 0.0012 && Math.abs(this.rotVel.y) < 0.0012) return;

                const boost = hand.isPinching ? 3.2 : 4.3;
                this.app.modelRotation.y += this.rotVel.x * boost;
                this.app.modelRotation.x += this.rotVel.y * boost;
            }

            applyScale() {
                const h0 = this.handData[0];
                const h1 = this.handData[1];
                if (!h0 || !h1 || !this.app.obj || this.scaleStartDistance < 0.01) return;

                const dx = h1.pinchPoint.x - h0.pinchPoint.x;
                const dy = h1.pinchPoint.y - h0.pinchPoint.y;
                const dist = Math.hypot(dx, dy);
                const ratio = dist / this.scaleStartDistance;
                const newScale = clamp(this.scaleStartValue * ratio, 0.2, 4);

                this.app.obj.scale.setScalar(newScale);
                const pct = Math.round(newScale * 100);
                const arrow = ratio > 1.05 ? " ‚Üë" : ratio < 0.95 ? " ‚Üì" : "";
                this.showStatus("üëåüëå", pct + "%" + arrow);
            }

            checkReset() {
                const elapsed = Date.now() - this.twoHandOpenStart;
                const progress = Math.min(100, (elapsed / 2000) * 100);
                this.progressEl.style.setProperty("--progress", progress + "%");

                if (elapsed >= 2000) {
                    this.app.resetRotation();
                    if (this.app.obj) this.app.obj.scale.setScalar(1);
                    this.showStatus("‚Ü∫", "Reset!");
                    this.twoHandOpenStart = Date.now() + 900;
                    this.app.showToast("Rotation and scale reset");
                    setTimeout(() => {
                        if (this.state === "TWO_HAND_EXIT") this.showStatus("‚úã‚úã", "Hold to reset");
                    }, 500);
                }
            }

            showStatus(icon, text) {
                this.statusIcon.textContent = icon;
                this.statusText.textContent = text;
            }

            drawHands(ctx, ovr) {
                if (!ctx) return;
                const w = ovr.width;
                const h = ovr.height;
                ctx.save();
                ctx.translate(w, 0);
                ctx.scale(-1, 1);

                for (let i = 0; i < this.handsDetected; i++) {
                    const hand = this.handData[i];
                    if (!hand) continue;
                    const lm = hand.landmarks;

                    let color = "#707f9a";
                    if (hand.isOpen) color = "#ff4c68";
                    if (hand.rotateCandidate) color = "#ff6a00";
                    if (hand.isPinching) color = "#22e08a";

                    const conns = [[0,1],[1,2],[2,3],[3,4],[0,5],[5,6],[6,7],[7,8],[0,9],[9,10],[10,11],[11,12],[0,13],[13,14],[14,15],[15,16],[0,17],[17,18],[18,19],[19,20],[5,9],[9,13],[13,17]];
                    ctx.strokeStyle = color;
                    ctx.lineWidth = 2;

                    conns.forEach(pair => {
                        ctx.beginPath();
                        ctx.moveTo(lm[pair[0]].x * w, lm[pair[0]].y * h);
                        ctx.lineTo(lm[pair[1]].x * w, lm[pair[1]].y * h);
                        ctx.stroke();
                    });

                    lm.forEach((pt, idx) => {
                        ctx.beginPath();
                        ctx.arc(pt.x * w, pt.y * h, [4,8,12,16,20].includes(idx) ? 4 : 2, 0, Math.PI * 2);
                        ctx.fillStyle = "#f6f8ff";
                        ctx.fill();
                    });

                    if (hand.isPinching) {
                        ctx.beginPath();
                        ctx.arc(hand.pinchPoint.x * w, hand.pinchPoint.y * h, 6, 0, Math.PI * 2);
                        ctx.fillStyle = "#22e08a";
                        ctx.fill();
                    }
                }

                if (this.state === "TWO_HAND_SCALE" && this.handData[0] && this.handData[1]) {
                    const h0 = this.handData[0];
                    const h1 = this.handData[1];
                    ctx.setLineDash([4, 4]);
                    ctx.strokeStyle = "#22e08a";
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    ctx.moveTo(h0.pinchPoint.x * w, h0.pinchPoint.y * h);
                    ctx.lineTo(h1.pinchPoint.x * w, h1.pinchPoint.y * h);
                    ctx.stroke();
                    ctx.setLineDash([]);
                }

                ctx.restore();
            }
        }

        class App {
            constructor() {
                this.vid = $("vid");
                this.ovr = $("ovr");
                this.ctx = null;

                this.scene = null;
                this.camera = null;
                this.renderer = null;
                this.obj = null;
                this.tesseract = null;
                this.particles = null;

                this.face = { x: 0, y: 0, z: 400 };
                this.smooth = { x: 0, y: 0, z: 400 };
                this.tracking = false;

                this.mode = "view";
                this.modelRotation = { x: 0, y: 0, z: 0 };
                this.baseRotation = { x: 0, y: 0, z: 0 };

                this.handController = null;
                this.detector = null;

                this.lastTime = performance.now();
                this.particleTick = 0;
                this.toastTimer = 0;

                this.init();
            }

            async init() {
                this.setup3D();
                await this.setupCamera();
                await this.setupTracking();
                this.handController = new HandController(this);
                await this.handController.init();
                this.setupUI();
                this.animate();
                log("App ready", "ok");
            }

            showToast(message) {
                const el = $("toast");
                if (!el) return;
                el.textContent = message;
                el.classList.add("show");
                if (this.toastTimer) clearTimeout(this.toastTimer);
                this.toastTimer = setTimeout(() => {
                    el.classList.remove("show");
                }, 1600);
            }

            setup3D() {
                const canvas = $("canvas3d");
                this.scene = new THREE.Scene();
                this.scene.fog = new THREE.FogExp2(0x0b0c12, 0.00135);

                this.camera = new THREE.PerspectiveCamera(60, innerWidth / innerHeight, 1, 5000);
                this.camera.position.z = 400;

                this.renderer = new THREE.WebGLRenderer({ canvas, antialias: true, powerPreference: "high-performance" });
                this.renderer.setSize(innerWidth, innerHeight);
                this.renderer.setPixelRatio(Math.min(devicePixelRatio || 1, 2));
                this.renderer.setClearColor(0x0b0c12);

                this.scene.add(new THREE.AmbientLight(0xffffff, 0.27));

                const keyLight = new THREE.DirectionalLight(0xffffff, 0.86);
                keyLight.position.set(50, 100, 100);
                this.scene.add(keyLight);

                const rimLight = new THREE.DirectionalLight(0x00e8d3, 0.46);
                rimLight.position.set(-60, -50, -100);
                this.scene.add(rimLight);

                const accentLight = new THREE.PointLight(0xff6a00, 0.52, 900);
                accentLight.position.set(0, 150, -220);
                this.scene.add(accentLight);

                this.createRoom();
                this.createParticles();
                this.makeObj("cube");
            }

            createRoom() {
                const room = new THREE.Group();
                const gc = 0xff6a00;
                const gd = 0x130a07;
                const D = 500;
                const W = 420;
                const H = 320;

                const floor = new THREE.GridHelper(W * 2, 34, gc, gd);
                floor.position.set(0, -H / 2, -D / 2);
                floor.material.transparent = true;
                floor.material.opacity = 0.6;
                room.add(floor);

                const back = new THREE.GridHelper(W * 2, 34, gc, gd);
                back.rotation.x = Math.PI / 2;
                back.position.z = -D;
                back.material.transparent = true;
                back.material.opacity = 0.38;
                room.add(back);

                [-1, 1].forEach(side => {
                    const wall = new THREE.GridHelper(D, 22, gc, gd);
                    wall.rotation.z = Math.PI / 2;
                    wall.position.set(side * W, 0, -D / 2);
                    wall.material.transparent = true;
                    wall.material.opacity = 0.18;
                    room.add(wall);
                });

                const ceil = new THREE.GridHelper(W * 2, 34, gc, gd);
                ceil.position.set(0, H / 2, -D / 2);
                ceil.material.transparent = true;
                ceil.material.opacity = 0.07;
                room.add(ceil);

                const edgeMat = new THREE.LineBasicMaterial({ color: gc, transparent: true, opacity: 0.35 });
                [[-W, -H / 2], [W, -H / 2], [-W, H / 2], [W, H / 2]].forEach(point => {
                    const geo = new THREE.BufferGeometry().setFromPoints([
                        new THREE.Vector3(point[0], point[1], 0),
                        new THREE.Vector3(point[0], point[1], -D)
                    ]);
                    room.add(new THREE.Line(geo, edgeMat));
                });

                const horizonGeo = new THREE.PlaneGeometry(W * 3, 6);
                const horizonMat = new THREE.MeshBasicMaterial({
                    color: gc,
                    transparent: true,
                    opacity: 0.77
                });
                const horizon = new THREE.Mesh(horizonGeo, horizonMat);
                horizon.position.set(0, -H / 2 + 3, -D + 2);
                room.add(horizon);

                const glowGeo = new THREE.PlaneGeometry(W * 2, D);
                const glowMat = new THREE.MeshBasicMaterial({
                    color: gc,
                    transparent: true,
                    opacity: 0.045,
                    side: THREE.DoubleSide
                });
                const glow = new THREE.Mesh(glowGeo, glowMat);
                glow.rotation.x = -Math.PI / 2;
                glow.position.set(0, -H / 2 + 1, -D / 2);
                room.add(glow);

                this.scene.add(room);
            }

            createParticles() {
                const count = 120;
                const positions = new Float32Array(count * 3);

                for (let i = 0; i < count; i++) {
                    positions[i * 3] = (Math.random() - 0.5) * 820;
                    positions[i * 3 + 1] = (Math.random() - 0.5) * 440;
                    positions[i * 3 + 2] = -Math.random() * 520;
                }

                const geo = new THREE.BufferGeometry();
                geo.setAttribute("position", new THREE.BufferAttribute(positions, 3));

                const mat = new THREE.PointsMaterial({
                    color: 0xff7f2c,
                    size: 2,
                    transparent: true,
                    opacity: 0.35,
                    sizeAttenuation: true
                });

                this.particles = new THREE.Points(geo, mat);
                this.scene.add(this.particles);
            }

            makeObj(type) {
                if (this.obj) this.scene.remove(this.obj);
                this.tesseract = null;
                $("modelInfo").classList.remove("show");

                this.modelRotation = { x: 0, y: 0, z: 0 };
                this.baseRotation = { x: 0, y: 0, z: 0 };

                if (type === "cube") {
                    const g = new THREE.Group();

                    const cube = new THREE.Mesh(
                        new THREE.BoxGeometry(90, 90, 90),
                        new THREE.MeshPhysicalMaterial({
                            color: 0xff6a00,
                            metalness: 0.33,
                            roughness: 0.38,
                            clearcoat: 0.52
                        })
                    );
                    g.add(cube);

                    const wire = new THREE.Mesh(
                        new THREE.BoxGeometry(92, 92, 92),
                        new THREE.MeshBasicMaterial({
                            color: 0xffffff,
                            wireframe: true,
                            transparent: true,
                            opacity: 0.14
                        })
                    );
                    g.add(wire);

                    const edges = new THREE.EdgesGeometry(new THREE.BoxGeometry(90, 90, 90));
                    const edgeLine = new THREE.LineSegments(
                        edges,
                        new THREE.LineBasicMaterial({ color: 0x00e8d3, transparent: true, opacity: 0.4 })
                    );
                    g.add(edgeLine);

                    g.position.z = -80;
                    this.obj = g;
                } else if (type === "tesseract") {
                    this.tesseract = new Tesseract();
                    this.obj = this.tesseract.group;
                } else if (type === "torus") {
                    const g = new THREE.Group();

                    const knot = new THREE.Mesh(
                        new THREE.TorusKnotGeometry(50, 15, 100, 16),
                        new THREE.MeshPhysicalMaterial({
                            color: 0xff6a00,
                            metalness: 0.3,
                            roughness: 0.38,
                            clearcoat: 0.45
                        })
                    );
                    g.add(knot);

                    const wire = new THREE.Mesh(
                        new THREE.TorusKnotGeometry(50, 15, 100, 16),
                        new THREE.MeshBasicMaterial({
                            color: 0x00e8d3,
                            wireframe: true,
                            transparent: true,
                            opacity: 0.1
                        })
                    );
                    g.add(wire);

                    g.position.z = -80;
                    this.obj = g;
                } else if (type === "gem") {
                    const g = new THREE.Group();

                    const gem = new THREE.Mesh(
                        new THREE.OctahedronGeometry(60, 0),
                        new THREE.MeshPhysicalMaterial({
                            color: 0x00e8d3,
                            metalness: 0.08,
                            roughness: 0.09,
                            clearcoat: 1,
                            transparent: true,
                            opacity: 0.9
                        })
                    );
                    g.add(gem);

                    [0xff6a00, 0x00e8d3, 0xff4c68].forEach((c, i) => {
                        const ring = new THREE.Mesh(
                            new THREE.TorusGeometry(80 + i * 20, 1.5, 8, 64),
                            new THREE.MeshBasicMaterial({ color: c, transparent: true, opacity: 0.6 })
                        );
                        ring.rotation.x = Math.PI / 2 + i * 0.4;
                        ring.rotation.y = i * 0.5;
                        ring.userData.speed = 0.008 + i * 0.004;
                        g.add(ring);
                    });

                    g.position.z = -80;
                    this.obj = g;
                }

                if (this.obj) this.scene.add(this.obj);
            }

            loadModel(file) {
                const ext = file.name.split(".").pop().toLowerCase();
                $("loading").classList.add("show");
                $("loadTxt").textContent = "Loading " + file.name + "...";

                const reader = new FileReader();
                reader.onload = e => {
                    try {
                        const geo = ext === "obj"
                            ? parseOBJ(typeof e.target.result === "string" ? e.target.result : new TextDecoder().decode(e.target.result))
                            : parseSTL(e.target.result);

                        if (!geo || !geo.attributes.position || geo.attributes.position.count < 3) {
                            throw new Error("Invalid or empty geometry");
                        }

                        geo.computeBoundingBox();
                        const box = geo.boundingBox;
                        const center = new THREE.Vector3();
                        box.getCenter(center);
                        geo.translate(-center.x, -center.y, -center.z);

                        const size = new THREE.Vector3();
                        box.getSize(size);
                        const maxSide = Math.max(size.x, size.y, size.z) || 1;
                        const scale = 120 / maxSide;
                        geo.scale(scale, scale, scale);
                        geo.computeVertexNormals();

                        if (this.obj) this.scene.remove(this.obj);
                        this.tesseract = null;

                        const mat = new THREE.MeshPhysicalMaterial({
                            color: 0xff6a00,
                            metalness: 0.31,
                            roughness: 0.42,
                            clearcoat: 0.3,
                            side: THREE.DoubleSide
                        });

                        const mesh = new THREE.Mesh(geo, mat);
                        const group = new THREE.Group();
                        group.add(mesh);
                        group.position.z = -80;

                        this.modelRotation = { x: 0, y: 0, z: 0 };
                        this.baseRotation = { x: 0, y: 0, z: 0 };
                        this.obj = group;
                        this.scene.add(this.obj);

                        $("modelName").textContent = file.name;
                        $("modelMeta").textContent = Math.round(geo.attributes.position.count / 3) + " faces";
                        $("modelInfo").classList.add("show");

                        document.querySelectorAll(".obj-btn").forEach(b => b.classList.remove("active"));
                        this.showToast("Model loaded");

                        $("loading").classList.remove("show");
                    } catch (err) {
                        $("loading").classList.remove("show");
                        alert("Error loading model: " + err.message);
                    }
                };

                reader.onerror = () => {
                    $("loading").classList.remove("show");
                    alert("Error reading file");
                };

                if (ext === "obj") reader.readAsText(file);
                else reader.readAsArrayBuffer(file);
            }

            async setupCamera() {
                setDebug("dCam", "...");

                try {
                    const stream = await navigator.mediaDevices.getUserMedia({
                        video: {
                            facingMode: "user",
                            width: { ideal: 320 },
                            height: { ideal: 240 }
                        },
                        audio: false
                    });

                    this.vid.srcObject = stream;

                    await new Promise((res, rej) => {
                        this.vid.onloadedmetadata = () => {
                            this.ovr.width = this.vid.videoWidth;
                            this.ovr.height = this.vid.videoHeight;
                            this.ctx = this.ovr.getContext("2d");
                            this.vid.play().then(res).catch(rej);
                        };
                        setTimeout(() => rej(new Error("Timeout")), 8000);
                    });

                    setDebug("dCam", "OK", "ok");
                    $("pipStatus").textContent = "READY";
                    $("pipStatus").classList.remove("off");
                } catch (err) {
                    setDebug("dCam", "FAIL", "err");
                    $("pipStatus").textContent = "NO CAM";
                    $("pipStatus").classList.add("off");
                    this.setupTouchFallback();
                }
            }

            setupTouchFallback() {
                setDebug("dTrack", "Touch");

                const update = (x, y) => {
                    if (this.mode !== "view") return;
                    this.face.x = -((x / innerWidth) - 0.5) * 400;
                    this.face.y = -((y / innerHeight) - 0.5) * 300;
                    this.tracking = true;
                };

                document.addEventListener("mousemove", e => update(e.clientX, e.clientY));
                document.addEventListener("touchmove", e => {
                    if (e.touches.length === 1) update(e.touches[0].clientX, e.touches[0].clientY);
                }, { passive: true });
            }

            async setupTracking() {
                if (!this.vid.srcObject) {
                    setDebug("dTrack", "None", "err");
                    return;
                }

                setDebug("dTrack", "...");

                if (typeof FaceDetection !== "undefined") {
                    try {
                        this.detector = new FaceDetection({
                            locateFile: f => "https://cdn.jsdelivr.net/npm/@mediapipe/face_detection/" + f
                        });

                        this.detector.setOptions({ model: "short", minDetectionConfidence: 0.5 });
                        this.detector.onResults(r => this.onFace(r));

                        setDebug("dTrack", "Face", "ok");
                        this.runFaceDetection();
                        return;
                    } catch (err) {
                        log("Face detection failed: " + err.message, "w");
                    }
                }

                setDebug("dTrack", "Basic");
                this.setupTouchFallback();
            }

            runFaceDetection() {
                const detect = async () => {
                    if (this.detector && this.vid.readyState >= 2 && this.mode === "view") {
                        try {
                            await this.detector.send({ image: this.vid });
                        } catch (e) {
                            // Ignore intermittent inference errors.
                        }
                    }
                    requestAnimationFrame(detect);
                };
                detect();
            }

            onFace(results) {
                if (this.mode !== "view") return;

                if (results.detections && results.detections.length > 0) {
                    const b = results.detections[0].boundingBox;
                    this.face.x = -(b.xCenter - 0.5) * 2 * 250;
                    this.face.y = -(b.yCenter - 0.5) * 2 * 180;
                    const fSize = Math.max(b.width, b.height);
                    this.face.z = clamp(350 / Math.max(0.15, fSize), 200, 700);
                    this.tracking = true;
                    $("rec").classList.add("on");
                    $("pipStatus").textContent = "TRACKING";
                } else {
                    this.tracking = false;
                    $("rec").classList.remove("on");
                    $("pipStatus").textContent = "SEARCHING";
                }
            }

            setMode(mode) {
                this.mode = mode;
                setDebug("dMode", mode.toUpperCase());

                document.querySelectorAll(".mode-btn").forEach(b => {
                    b.classList.remove("active");
                    if (b.dataset.mode === mode) b.classList.add("active");
                });

                const viewBtn = document.querySelector('.mode-btn[data-mode="view"]');
                const editBtn = document.querySelector('.mode-btn[data-mode="edit"]');

                if (mode === "view") {
                    editBtn.classList.remove("edit");
                    $("objectSelector").classList.remove("hidden");
                    $("pip").classList.remove("edit-mode");
                    if (this.handController) this.handController.stop();
                    this.showToast("View mode");
                } else {
                    editBtn.classList.add("edit");
                    viewBtn.classList.remove("edit");
                    $("objectSelector").classList.add("hidden");
                    $("pip").classList.add("edit-mode");
                    if (this.handController && this.handController.ready) {
                        this.handController.start();
                    }
                    this.showToast("Edit mode: fist or pinch to rotate");
                }
            }

            resetRotation() {
                this.modelRotation = { x: 0, y: 0, z: 0 };
            }

            setupUI() {
                document.querySelectorAll(".obj-btn[data-obj]").forEach(btn => {
                    btn.onclick = () => {
                        document.querySelectorAll(".obj-btn").forEach(b => b.classList.remove("active"));
                        btn.classList.add("active");
                        this.makeObj(btn.dataset.obj);
                        this.showToast(btn.dataset.obj.toUpperCase() + " loaded");
                    };
                });

                $("uploadBtn").onclick = () => $("fileInput").click();
                $("fileInput").onchange = e => {
                    if (e.target.files[0]) this.loadModel(e.target.files[0]);
                    e.target.value = "";
                };

                $("clearModel").onclick = () => {
                    this.makeObj("cube");
                    document.querySelectorAll(".obj-btn").forEach(b => b.classList.remove("active"));
                    const cubeBtn = document.querySelector('.obj-btn[data-obj="cube"]');
                    if (cubeBtn) cubeBtn.classList.add("active");
                    this.showToast("Default cube restored");
                };

                document.querySelectorAll(".mode-btn").forEach(btn => {
                    btn.onclick = () => this.setMode(btn.dataset.mode);
                });

                $("debugToggle").onclick = () => {
                    $("debugPanel").classList.toggle("show");
                    $("debugToggle").classList.toggle("active");
                };

                $("helpBtn").onclick = () => $("gestureHelp").classList.add("show");
                $("closeHelp").onclick = () => $("gestureHelp").classList.remove("show");

                window.addEventListener("resize", () => {
                    this.camera.aspect = innerWidth / innerHeight;
                    this.camera.updateProjectionMatrix();
                    this.renderer.setSize(innerWidth, innerHeight);
                });

                this.setupTouchRotation();
                this.setupKeyboardShortcuts();
            }

            setupTouchRotation() {
                const canvas = $("canvas3d");
                let rotateStart = null;
                let pinchStart = null;

                canvas.addEventListener("touchstart", e => {
                    if (this.mode !== "edit") return;

                    if (e.touches.length === 1) {
                        const t = e.touches[0];
                        rotateStart = {
                            x: t.clientX,
                            y: t.clientY,
                            rotX: this.modelRotation.x,
                            rotY: this.modelRotation.y
                        };
                    } else if (e.touches.length === 2 && this.obj) {
                        const t1 = e.touches[0];
                        const t2 = e.touches[1];
                        const dx = t2.clientX - t1.clientX;
                        const dy = t2.clientY - t1.clientY;
                        pinchStart = {
                            d: Math.hypot(dx, dy),
                            scale: this.obj.scale.x
                        };
                    }
                }, { passive: true });

                canvas.addEventListener("touchmove", e => {
                    if (this.mode !== "edit") return;

                    if (e.touches.length === 1 && rotateStart) {
                        const t = e.touches[0];
                        this.modelRotation.y = rotateStart.rotY + (t.clientX - rotateStart.x) * 0.01;
                        this.modelRotation.x = rotateStart.rotX + (t.clientY - rotateStart.y) * 0.01;
                    } else if (e.touches.length === 2 && pinchStart && this.obj) {
                        const t1 = e.touches[0];
                        const t2 = e.touches[1];
                        const dx = t2.clientX - t1.clientX;
                        const dy = t2.clientY - t1.clientY;
                        const d = Math.hypot(dx, dy);
                        const ratio = d / (pinchStart.d || 1);
                        this.obj.scale.setScalar(clamp(pinchStart.scale * ratio, 0.2, 4));
                    }
                }, { passive: true });

                canvas.addEventListener("touchend", () => {
                    rotateStart = null;
                    pinchStart = null;
                }, { passive: true });

                let mouseDown = false;
                let mouseStart = null;

                canvas.addEventListener("mousedown", e => {
                    if (this.mode !== "edit") return;
                    mouseDown = true;
                    mouseStart = {
                        x: e.clientX,
                        y: e.clientY,
                        rotX: this.modelRotation.x,
                        rotY: this.modelRotation.y
                    };
                });

                canvas.addEventListener("mousemove", e => {
                    if (!mouseDown || !mouseStart) return;
                    this.modelRotation.y = mouseStart.rotY + (e.clientX - mouseStart.x) * 0.005;
                    this.modelRotation.x = mouseStart.rotX + (e.clientY - mouseStart.y) * 0.005;
                });

                canvas.addEventListener("mouseup", () => { mouseDown = false; });
                canvas.addEventListener("mouseleave", () => { mouseDown = false; });
            }

            setupKeyboardShortcuts() {
                window.addEventListener("keydown", e => {
                    if (this.mode !== "edit") return;

                    const step = 0.07;
                    if (e.key === "ArrowLeft") this.modelRotation.y -= step;
                    else if (e.key === "ArrowRight") this.modelRotation.y += step;
                    else if (e.key === "ArrowUp") this.modelRotation.x -= step;
                    else if (e.key === "ArrowDown") this.modelRotation.x += step;
                    else if (e.key === "+" || e.key === "=") {
                        if (this.obj) this.obj.scale.setScalar(clamp(this.obj.scale.x + 0.08, 0.2, 4));
                    } else if (e.key === "-") {
                        if (this.obj) this.obj.scale.setScalar(clamp(this.obj.scale.x - 0.08, 0.2, 4));
                    } else if (e.key.toLowerCase() === "r") {
                        this.resetRotation();
                        if (this.obj) this.obj.scale.setScalar(1);
                    } else {
                        return;
                    }

                    e.preventDefault();
                });
            }

            updateProjection() {
                if (this.mode === "view") {
                    this.smooth.x += (this.face.x - this.smooth.x) * 0.1;
                    this.smooth.y += (this.face.y - this.smooth.y) * 0.1;
                    this.smooth.z += (this.face.z - this.smooth.z) * 0.1;
                }

                const x = this.smooth.x;
                const y = this.smooth.y;
                const z = this.smooth.z;
                const asp = innerWidth / innerHeight;
                const hw = 180;
                const hh = hw / asp;
                const n = 10;
                const f = 3000;
                const r = n / z;

                this.camera.projectionMatrix.makePerspective(
                    (-hw - x) * r,
                    (hw - x) * r,
                    (hh - y) * r,
                    (-hh - y) * r,
                    n,
                    f
                );
                this.camera.projectionMatrixInverse.copy(this.camera.projectionMatrix).invert();
                this.camera.position.set(x, y, z);
                this.camera.lookAt(x, y, -200);
            }

            animate() {
                requestAnimationFrame(() => this.animate());

                const now = performance.now();
                const dt = Math.min(0.04, (now - this.lastTime) / 1000);
                this.lastTime = now;

                updateFPS();
                this.updateProjection();

                if (this.tesseract) {
                    this.tesseract.update(dt);
                }

                if (this.particles && (!prefersReducedMotion || this.particleTick % 2 === 0)) {
                    const pos = this.particles.geometry.attributes.position.array;
                    for (let i = 0; i < pos.length; i += 3) {
                        pos[i + 2] += dt * 20;
                        if (pos[i + 2] > 0) pos[i + 2] = -520;
                    }
                    this.particles.geometry.attributes.position.needsUpdate = true;
                }
                this.particleTick += 1;

                if (this.obj && !this.tesseract) {
                    this.obj.rotation.x = this.baseRotation.x + this.modelRotation.x;
                    this.obj.rotation.y = this.baseRotation.y + this.modelRotation.y;
                    this.obj.rotation.z = this.baseRotation.z + this.modelRotation.z;

                    this.obj.children.forEach(c => {
                        if (c.userData && c.userData.speed) {
                            c.rotation.z += c.userData.speed;
                        }
                    });
                }

                this.renderer.render(this.scene, this.camera);
            }
        }

        new App();
    })();
    </script>
</body>
</html>
