<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <title>OffAxis 3D</title>
    <style>
        :root {
            --bg: #08080c;
            --primary: #ff6a00;
            --primary-dim: rgba(255,106,0,0.3);
            --accent: #00f0ff;
            --success: #00ff88;
            --danger: #ff4466;
            --text: #ffffff;
            --text-dim: #666;
            --panel: rgba(12,12,18,0.9);
            --border: rgba(255,255,255,0.1);
        }
        
        * { margin: 0; padding: 0; box-sizing: border-box; }
        
        body {
            background: var(--bg);
            overflow: hidden;
            font-family: 'SF Pro Display', -apple-system, system-ui, sans-serif;
            touch-action: none;
            color: var(--text);
        }
        
        #canvas3d {
            width: 100vw;
            height: 100vh;
            display: block;
        }
        
        /* ===== PIP Camera ===== */
        #pip {
            position: fixed;
            bottom: 24px;
            right: 24px;
            width: 120px;
            height: 90px;
            border-radius: 16px;
            overflow: hidden;
            z-index: 100;
            background: #000;
            border: 2px solid var(--primary-dim);
            box-shadow: 0 8px 32px rgba(0,0,0,0.5);
            transition: all 0.3s ease;
        }
        #pip:hover { transform: scale(1.05); }
        #pip.edit-mode {
            border-color: var(--success);
            box-shadow: 0 8px 32px rgba(0,255,136,0.2);
        }
        #pip video {
            width: 100%;
            height: 100%;
            object-fit: cover;
            transform: scaleX(-1);
        }
        #pip canvas {
            position: absolute;
            top: 0; left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
        }
        #pip .status {
            position: absolute;
            bottom: 6px;
            left: 50%;
            transform: translateX(-50%);
            font-size: 9px;
            font-weight: 600;
            padding: 2px 8px;
            border-radius: 8px;
            background: rgba(0,0,0,0.7);
            color: var(--success);
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }
        #pip .status.off { color: var(--danger); }
        #pip .rec {
            position: absolute;
            top: 8px;
            left: 8px;
            width: 8px;
            height: 8px;
            border-radius: 50%;
            background: var(--danger);
            opacity: 0.5;
        }
        #pip .rec.on { 
            opacity: 1;
            animation: pulse 1s infinite;
        }
        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.4; }
        }
        
        /* ===== Object Selector (Bottom Pills) ===== */
        #objectSelector {
            position: fixed;
            bottom: 24px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            gap: 4px;
            padding: 6px;
            background: var(--panel);
            border-radius: 28px;
            border: 1px solid var(--border);
            z-index: 100;
            backdrop-filter: blur(20px);
            transition: all 0.3s ease;
        }
        #objectSelector.hidden {
            opacity: 0;
            pointer-events: none;
            transform: translateX(-50%) translateY(20px);
        }
        .obj-btn {
            width: 44px;
            height: 44px;
            border-radius: 22px;
            border: none;
            background: transparent;
            color: var(--text-dim);
            font-size: 11px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s ease;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            gap: 2px;
        }
        .obj-btn .icon { font-size: 18px; }
        .obj-btn:hover { color: var(--text); background: rgba(255,255,255,0.05); }
        .obj-btn.active {
            background: var(--primary);
            color: white;
            box-shadow: 0 4px 12px var(--primary-dim);
        }
        .obj-btn.upload {
            border: 2px dashed var(--border);
            background: transparent;
        }
        .obj-btn.upload:hover {
            border-color: var(--primary);
            color: var(--primary);
        }
        
        /* ===== Mode Toggle ===== */
        #modeToggle {
            position: fixed;
            bottom: 90px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            background: var(--panel);
            border-radius: 25px;
            padding: 4px;
            border: 1px solid var(--border);
            z-index: 200;
            backdrop-filter: blur(20px);
        }
        .mode-btn {
            padding: 10px 24px;
            border: none;
            border-radius: 21px;
            background: transparent;
            color: var(--text-dim);
            font-size: 13px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s ease;
            display: flex;
            align-items: center;
            gap: 6px;
        }
        .mode-btn .icon { font-size: 16px; }
        .mode-btn.active {
            background: var(--primary);
            color: white;
            box-shadow: 0 4px 16px var(--primary-dim);
        }
        .mode-btn.active.edit {
            background: var(--success);
            box-shadow: 0 4px 16px rgba(0,255,136,0.3);
        }
        
        /* ===== Gesture Status ===== */
        #gestureStatus {
            position: fixed;
            bottom: 150px;
            left: 50%;
            transform: translateX(-50%);
            background: var(--panel);
            border: 2px solid var(--border);
            border-radius: 24px;
            padding: 10px 20px;
            z-index: 160;
            display: none;
            align-items: center;
            gap: 10px;
            min-width: 140px;
            justify-content: center;
            backdrop-filter: blur(20px);
            transition: all 0.2s ease;
        }
        #gestureStatus.show { display: flex; }
        #gestureStatus.scale { border-color: var(--success); }
        #gestureStatus.rotate { border-color: var(--primary); }
        #gestureStatus.reset { border-color: var(--danger); }
        #gestureStatus .icon { font-size: 20px; }
        #gestureStatus .text { font-size: 13px; font-weight: 600; }
        #gestureStatus .progress {
            position: absolute;
            bottom: 0;
            left: 16px;
            right: 16px;
            height: 3px;
            background: rgba(255,255,255,0.1);
            border-radius: 2px;
            overflow: hidden;
        }
        #gestureStatus .progress::after {
            content: '';
            position: absolute;
            left: 0; top: 0;
            height: 100%;
            width: var(--progress, 0%);
            background: var(--danger);
            transition: width 0.1s;
        }
        
        /* ===== Model Info ===== */
        #modelInfo {
            position: fixed;
            top: 24px;
            left: 50%;
            transform: translateX(-50%);
            background: var(--panel);
            padding: 10px 20px;
            border-radius: 20px;
            border: 1px solid var(--border);
            font-size: 12px;
            z-index: 100;
            display: none;
            align-items: center;
            gap: 10px;
            backdrop-filter: blur(20px);
        }
        #modelInfo.show { display: flex; }
        #modelInfo .icon { font-size: 16px; }
        #modelInfo .name { 
            color: var(--primary); 
            font-weight: 600;
            max-width: 150px; 
            overflow: hidden; 
            text-overflow: ellipsis; 
            white-space: nowrap; 
        }
        #modelInfo .meta { color: var(--text-dim); font-size: 11px; }
        #modelInfo .close { 
            background: none; 
            border: none; 
            color: var(--text-dim); 
            font-size: 16px; 
            cursor: pointer;
            padding: 4px;
            margin-left: 4px;
        }
        #modelInfo .close:hover { color: var(--text); }
        
        /* ===== Debug Panel (Hidden by default) ===== */
        #debugPanel {
            position: fixed;
            top: 24px;
            right: 24px;
            background: var(--panel);
            border: 1px solid var(--border);
            border-radius: 12px;
            padding: 12px;
            font-size: 10px;
            font-family: 'SF Mono', monospace;
            z-index: 100;
            min-width: 140px;
            backdrop-filter: blur(20px);
            transition: all 0.3s ease;
            opacity: 0;
            pointer-events: none;
            transform: translateY(-10px);
        }
        #debugPanel.show {
            opacity: 1;
            pointer-events: auto;
            transform: translateY(0);
        }
        #debugPanel .row { 
            display: flex; 
            justify-content: space-between; 
            padding: 3px 0;
            border-bottom: 1px solid var(--border);
        }
        #debugPanel .row:last-child { border-bottom: none; }
        #debugPanel .label { color: var(--text-dim); }
        #debugPanel .value { color: var(--primary); font-weight: 600; }
        #debugPanel .value.ok { color: var(--success); }
        #debugPanel .value.err { color: var(--danger); }
        
        /* Debug toggle button */
        #debugToggle {
            position: fixed;
            top: 24px;
            right: 24px;
            width: 36px;
            height: 36px;
            border-radius: 18px;
            border: 1px solid var(--border);
            background: var(--panel);
            color: var(--text-dim);
            font-size: 14px;
            cursor: pointer;
            z-index: 101;
            backdrop-filter: blur(20px);
            transition: all 0.2s ease;
        }
        #debugToggle:hover { 
            color: var(--text);
            border-color: var(--primary);
        }
        #debugToggle.active {
            right: 180px;
            color: var(--primary);
        }
        
        /* ===== Gesture Help Overlay ===== */
        #gestureHelp {
            position: fixed;
            inset: 0;
            background: rgba(0,0,0,0.9);
            display: none;
            align-items: center;
            justify-content: center;
            z-index: 600;
            backdrop-filter: blur(10px);
        }
        #gestureHelp.show { display: flex; }
        #gestureHelp .content {
            background: var(--panel);
            border: 1px solid var(--border);
            border-radius: 24px;
            padding: 32px;
            text-align: center;
            max-width: 320px;
        }
        #gestureHelp h3 {
            font-size: 20px;
            margin-bottom: 24px;
            font-weight: 600;
        }
        #gestureHelp .gesture-row {
            display: flex;
            align-items: center;
            gap: 16px;
            padding: 12px 0;
            border-bottom: 1px solid var(--border);
            font-size: 14px;
        }
        #gestureHelp .gesture-row:last-of-type { border-bottom: none; }
        #gestureHelp .gesture-row .icon { font-size: 28px; width: 50px; }
        #gestureHelp .gesture-row .desc { text-align: left; color: var(--text-dim); }
        #gestureHelp button {
            margin-top: 24px;
            background: var(--primary);
            border: none;
            border-radius: 20px;
            padding: 12px 32px;
            color: white;
            font-size: 14px;
            font-weight: 600;
            cursor: pointer;
        }
        
        /* Help button in edit mode */
        #helpBtn {
            position: fixed;
            bottom: 24px;
            left: 24px;
            width: 40px;
            height: 40px;
            border-radius: 20px;
            border: 1px solid var(--border);
            background: var(--panel);
            color: var(--text-dim);
            font-size: 16px;
            font-weight: 600;
            cursor: pointer;
            z-index: 150;
            display: none;
            backdrop-filter: blur(20px);
        }
        #helpBtn.show { display: flex; align-items: center; justify-content: center; }
        #helpBtn:hover { color: var(--text); border-color: var(--success); }
        
        /* ===== Loading Overlay ===== */
        #loading {
            position: fixed;
            inset: 0;
            background: rgba(8,8,12,0.95);
            display: none;
            align-items: center;
            justify-content: center;
            flex-direction: column;
            z-index: 500;
        }
        #loading.show { display: flex; }
        .spinner {
            width: 40px;
            height: 40px;
            border: 3px solid var(--border);
            border-top-color: var(--primary);
            border-radius: 50%;
            animation: spin 0.8s linear infinite;
        }
        @keyframes spin { to { transform: rotate(360deg); } }
        #loading p { 
            color: var(--text-dim); 
            margin-top: 16px; 
            font-size: 14px;
        }
        
        /* Hidden file input */
        #fileInput { display: none; }
        
        /* Tutorial animation */
        @keyframes tutorialPop {
            0% { transform: translate(-50%, -50%) scale(0.8); opacity: 0; }
            100% { transform: translate(-50%, -50%) scale(1); opacity: 1; }
        }
    </style>
</head>
<body>
    <canvas id="canvas3d"></canvas>
    
    <!-- PIP Camera -->
    <div id="pip">
        <video id="vid" playsinline autoplay muted></video>
        <canvas id="ovr"></canvas>
        <div class="rec" id="rec"></div>
        <div class="status" id="pipStatus">READY</div>
    </div>
    
    <!-- Object Selector -->
    <div id="objectSelector">
        <button class="obj-btn active" data-obj="cube">
            <span class="icon">‚ñ£</span>
            <span>Cube</span>
        </button>
        <button class="obj-btn" data-obj="torus">
            <span class="icon">‚óé</span>
            <span>Knot</span>
        </button>
        <button class="obj-btn" data-obj="gem">
            <span class="icon">‚óá</span>
            <span>Gem</span>
        </button>
        <button class="obj-btn" data-obj="tesseract">
            <span class="icon">‚¨¢</span>
            <span>Hyper</span>
        </button>
        <button class="obj-btn upload" id="uploadBtn">
            <span class="icon">+</span>
        </button>
    </div>
    <input type="file" id="fileInput" accept=".stl,.STL,.obj,.OBJ">
    
    <!-- Mode Toggle -->
    <div id="modeToggle">
        <button class="mode-btn active" data-mode="view">
            <span class="icon">üëÅ</span>
            <span>View</span>
        </button>
        <button class="mode-btn" data-mode="edit">
            <span class="icon">‚úã</span>
            <span>Edit</span>
        </button>
    </div>
    
    <!-- Gesture Status -->
    <div id="gestureStatus">
        <span class="icon">üëã</span>
        <span class="text">Show hands</span>
        <div class="progress"></div>
    </div>
    
    <!-- Model Info -->
    <div id="modelInfo">
        <span class="icon">üì¶</span>
        <span class="name" id="modelName"></span>
        <span class="meta" id="modelMeta"></span>
        <button class="close" id="clearModel">‚úï</button>
    </div>
    
    <!-- Debug Toggle -->
    <button id="debugToggle">‚öô</button>
    
    <!-- Debug Panel -->
    <div id="debugPanel">
        <div class="row"><span class="label">Mode</span><span class="value" id="dMode">VIEW</span></div>
        <div class="row"><span class="label">Camera</span><span class="value" id="dCam">--</span></div>
        <div class="row"><span class="label">Track</span><span class="value" id="dTrack">--</span></div>
        <div class="row"><span class="label">Hands</span><span class="value" id="dHands">0</span></div>
        <div class="row"><span class="label">FPS</span><span class="value" id="dFPS">--</span></div>
    </div>
    
    <!-- Gesture Help -->
    <div id="gestureHelp">
        <div class="content">
            <h3>Hand Gestures</h3>
            <div class="gesture-row">
                <span class="icon">‚úä</span>
                <span class="desc">Fist + drag to rotate model</span>
            </div>
            <div class="gesture-row">
                <span class="icon">üëåüëå</span>
                <span class="desc">Two pinch, spread to scale</span>
            </div>
            <div class="gesture-row">
                <span class="icon">‚úã‚úã</span>
                <span class="desc">Both open, hold 2s to reset</span>
            </div>
            <button id="closeHelp">Got it</button>
        </div>
    </div>
    
    <!-- Help Button -->
    <button id="helpBtn">?</button>
    
    <!-- Loading -->
    <div id="loading">
        <div class="spinner"></div>
        <p id="loadTxt">Loading...</p>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/face_detection/face_detection.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js" crossorigin="anonymous"></script>
    
    <script>
    (function() {
        'use strict';
        
        const $ = id => document.getElementById(id);
        
        // ============ LOGGING ============
        function log(msg, type = '') {
            console.log(`[${type||'i'}] ${msg}`);
        }
        
        function setDebug(id, val, status = '') {
            const el = $(id);
            if (el) {
                el.textContent = val;
                el.className = 'value ' + status;
            }
        }
        
        // ============ FPS COUNTER ============
        let frameCount = 0;
        let lastFpsTime = performance.now();
        function updateFPS() {
            frameCount++;
            const now = performance.now();
            if (now - lastFpsTime >= 1000) {
                setDebug('dFPS', frameCount);
                frameCount = 0;
                lastFpsTime = now;
            }
        }
        
        // ============ STL PARSER ============
        function parseSTL(buffer) {
            const isBinary = data => {
                const reader = new DataView(data);
                const faceSize = (32/8*3) + ((32/8*3)*3) + (16/8);
                const nFaces = reader.getUint32(80, true);
                const expect = 80 + (32/8) + (nFaces * faceSize);
                if (expect === reader.byteLength) return true;
                const solid = [115, 111, 108, 105, 100];
                for (let i = 0; i < 5; i++) {
                    if (solid[i] !== reader.getUint8(i)) return true;
                }
                return false;
            };
            
            const parseBinary = data => {
                const reader = new DataView(data);
                const faces = reader.getUint32(80, true);
                const vertices = new Float32Array(faces * 9);
                const normals = new Float32Array(faces * 9);
                const dataOffset = 84, faceLength = 50;
                
                for (let face = 0; face < faces; face++) {
                    const start = dataOffset + face * faceLength;
                    const nx = reader.getFloat32(start, true);
                    const ny = reader.getFloat32(start + 4, true);
                    const nz = reader.getFloat32(start + 8, true);
                    
                    for (let i = 1; i <= 3; i++) {
                        const idx = (face * 9) + ((i-1) * 3);
                        vertices[idx] = reader.getFloat32(start + i*12, true);
                        vertices[idx+1] = reader.getFloat32(start + i*12 + 4, true);
                        vertices[idx+2] = reader.getFloat32(start + i*12 + 8, true);
                        normals[idx] = nx; normals[idx+1] = ny; normals[idx+2] = nz;
                    }
                }
                
                const geo = new THREE.BufferGeometry();
                geo.setAttribute('position', new THREE.BufferAttribute(vertices, 3));
                geo.setAttribute('normal', new THREE.BufferAttribute(normals, 3));
                return geo;
            };
            
            const parseASCII = text => {
                const vertices = [], normals = [];
                let currentNormal = [0, 0, 1];
                text.split('\n').forEach(line => {
                    const parts = line.trim().split(/\s+/);
                    if (parts[0] === 'facet' && parts[1] === 'normal') {
                        currentNormal = [parseFloat(parts[2]), parseFloat(parts[3]), parseFloat(parts[4])];
                    } else if (parts[0] === 'vertex') {
                        vertices.push(parseFloat(parts[1]), parseFloat(parts[2]), parseFloat(parts[3]));
                        normals.push(...currentNormal);
                    }
                });
                const geo = new THREE.BufferGeometry();
                geo.setAttribute('position', new THREE.Float32BufferAttribute(vertices, 3));
                geo.setAttribute('normal', new THREE.Float32BufferAttribute(normals, 3));
                return geo;
            };
            
            return isBinary(buffer) ? parseBinary(buffer) : parseASCII(new TextDecoder().decode(buffer));
        }
        
        // ============ OBJ PARSER ============
        function parseOBJ(text) {
            const vertices = [], normals = [], outPos = [], outNorm = [];
            
            text.split('\n').forEach(line => {
                const parts = line.trim().split(/\s+/);
                if (parts[0] === 'v') vertices.push([+parts[1], +parts[2], +parts[3]]);
                else if (parts[0] === 'vn') normals.push([+parts[1], +parts[2], +parts[3]]);
            });
            
            text.split('\n').forEach(line => {
                const parts = line.trim().split(/\s+/);
                if (parts[0] !== 'f') return;
                const fv = [];
                for (let i = 1; i < parts.length; i++) {
                    const p = parts[i].split('/');
                    let vi = parseInt(p[0]) || 0;
                    let ni = parseInt(p[2]) || 0;
                    if (vi < 0) vi = vertices.length + vi + 1;
                    if (ni < 0) ni = normals.length + ni + 1;
                    fv.push({ v: vi - 1, n: ni - 1 });
                }
                for (let i = 1; i < fv.length - 1; i++) {
                    [fv[0], fv[i], fv[i+1]].forEach(f => {
                        const v = vertices[f.v] || [0,0,0];
                        outPos.push(...v);
                        if (f.n >= 0 && normals[f.n]) outNorm.push(...normals[f.n]);
                        else outNorm.push(0, 1, 0);
                    });
                }
            });
            
            const geo = new THREE.BufferGeometry();
            geo.setAttribute('position', new THREE.Float32BufferAttribute(outPos, 3));
            geo.setAttribute('normal', new THREE.Float32BufferAttribute(outNorm, 3));
            return geo;
        }
        
        // ============ TESSERACT (4D Hypercube) ============
        class Tesseract {
            constructor() {
                this.group = new THREE.Group();
                this.vertices4D = [];
                this.rotationXW = 0;
                this.rotationYW = 0;
                this.rotationZW = 0;
                
                // Scale factor for the final 3D projection
                this.scale3D = 60;
                
                // Generate 16 vertices of a 4D hypercube (¬±1 in each dimension)
                for (let i = 0; i < 16; i++) {
                    this.vertices4D.push([
                        (i & 1) ? 1 : -1,
                        (i & 2) ? 1 : -1,
                        (i & 4) ? 1 : -1,
                        (i & 8) ? 1 : -1
                    ]);
                }
                
                // Edges: connect vertices that differ in exactly one coordinate (32 edges total)
                this.edges = [];
                for (let i = 0; i < 16; i++) {
                    for (let j = i + 1; j < 16; j++) {
                        let diff = 0;
                        for (let k = 0; k < 4; k++) {
                            if (this.vertices4D[i][k] !== this.vertices4D[j][k]) diff++;
                        }
                        if (diff === 1) this.edges.push([i, j]);
                    }
                }
                
                // Create lines for each edge
                this.lines = [];
                this.edges.forEach(() => {
                    const geo = new THREE.BufferGeometry();
                    geo.setAttribute('position', new THREE.Float32BufferAttribute([0,0,0, 0,0,0], 3));
                    const mat = new THREE.LineBasicMaterial({ 
                        color: 0xff6a00,
                        transparent: true,
                        opacity: 0.8
                    });
                    const line = new THREE.Line(geo, mat);
                    this.lines.push(line);
                    this.group.add(line);
                });
                
                // Small vertex dots (fixed size, not scaled with group)
                this.dots = [];
                for (let i = 0; i < 16; i++) {
                    const dot = new THREE.Mesh(
                        new THREE.SphereGeometry(2.5, 8, 8),
                        new THREE.MeshBasicMaterial({ color: 0x00f0ff })
                    );
                    this.dots.push(dot);
                    this.group.add(dot);
                }
                
                this.group.position.z = -80;
                // NO group.scale - we handle scaling in projection
            }
            
            project4Dto3D(v4, rotXW, rotYW, rotZW) {
                let [x, y, z, w] = v4;
                
                // Rotate in XW plane
                const cosXW = Math.cos(rotXW), sinXW = Math.sin(rotXW);
                [x, w] = [x * cosXW - w * sinXW, x * sinXW + w * cosXW];
                
                // Rotate in YW plane  
                const cosYW = Math.cos(rotYW), sinYW = Math.sin(rotYW);
                [y, w] = [y * cosYW - w * sinYW, y * sinYW + w * cosYW];
                
                // Rotate in ZW plane
                const cosZW = Math.cos(rotZW), sinZW = Math.sin(rotZW);
                [z, w] = [z * cosZW - w * sinZW, z * sinZW + w * cosZW];
                
                // Perspective projection from 4D to 3D
                // Use a safe distance to prevent extreme values
                const distance = 2.5;
                const wClamped = Math.max(-1.5, Math.min(1.5, w)); // Clamp to prevent infinity
                const perspScale = distance / (distance - wClamped);
                
                return { 
                    x: x * perspScale * this.scale3D, 
                    y: y * perspScale * this.scale3D, 
                    z: z * perspScale * this.scale3D, 
                    w: wClamped 
                };
            }
            
            update(dt) {
                // Animate 4D rotation at different speeds for interesting motion
                this.rotationXW += dt * 0.4;
                this.rotationYW += dt * 0.25;
                this.rotationZW += dt * 0.15;
                
                // Project all vertices to 3D
                const projected = this.vertices4D.map(v => 
                    this.project4Dto3D(v, this.rotationXW, this.rotationYW, this.rotationZW)
                );
                
                // Update vertex dot positions and sizes
                projected.forEach((p, i) => {
                    this.dots[i].position.set(p.x, p.y, p.z);
                    // Size based on W coordinate (closer in 4D = larger)
                    const s = 0.6 + (p.w + 1.5) * 0.3;
                    this.dots[i].scale.setScalar(Math.max(0.3, Math.min(1.5, s)));
                });
                
                // Update edge lines
                this.edges.forEach(([a, b], i) => {
                    const pa = projected[a], pb = projected[b];
                    const positions = this.lines[i].geometry.attributes.position.array;
                    positions[0] = pa.x; positions[1] = pa.y; positions[2] = pa.z;
                    positions[3] = pb.x; positions[4] = pb.y; positions[5] = pb.z;
                    this.lines[i].geometry.attributes.position.needsUpdate = true;
                    
                    // Opacity based on average W depth (closer = more opaque)
                    const avgW = (pa.w + pb.w) / 2;
                    this.lines[i].material.opacity = 0.3 + (avgW + 1.5) * 0.25;
                });
            }
        }
        
        // ============ HAND CONTROLLER ============
        class HandController {
            constructor(app) {
                this.app = app;
                this.hands = null;
                this.ready = false;
                this.active = false;
                this.state = 'IDLE';
                this.stateStartTime = 0;
                
                this.handData = [null, null];
                this.handsDetected = 0;
                
                this.stableState = 'IDLE';
                this.stableStateStart = 0;
                this.requiredStableTime = 120;
                
                this.handCenter = { x: 0.5, y: 0.5 };
                this.prevHandCenter = { x: 0.5, y: 0.5 };
                
                this.scaleStartDistance = 0;
                this.scaleStartValue = 1;
                this.twoHandOpenStart = 0;
                this.hasShownHint = false;
                
                this.statusEl = $('gestureStatus');
                this.statusIcon = this.statusEl.querySelector('.icon');
                this.statusText = this.statusEl.querySelector('.text');
                this.progressEl = this.statusEl.querySelector('.progress');
            }
            
            async init() {
                if (typeof Hands === 'undefined') {
                    log('MediaPipe Hands not available', 'e');
                    return false;
                }
                
                try {
                    this.hands = new Hands({
                        locateFile: f => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${f}`
                    });
                    this.hands.setOptions({
                        maxNumHands: 2,
                        modelComplexity: 0,
                        minDetectionConfidence: 0.6,
                        minTrackingConfidence: 0.5
                    });
                    this.hands.onResults(r => this.onResults(r));
                    this.ready = true;
                    log('Hand tracking ready', 'ok');
                    return true;
                } catch (err) {
                    log(`Hand init failed: ${err.message}`, 'e');
                    return false;
                }
            }
            
            start() {
                if (!this.ready) return;
                this.active = true;
                this.state = 'IDLE';
                this.showStatus('üëã', 'Show hands');
                this.statusEl.classList.add('show');
                $('helpBtn').classList.add('show');
                
                if (!this.hasShownHint) {
                    this.hasShownHint = true;
                    setTimeout(() => {
                        if (this.active && this.state === 'IDLE') {
                            $('gestureHelp').classList.add('show');
                        }
                    }, 3000);
                }
                
                this.runDetection();
            }
            
            stop() {
                this.active = false;
                this.state = 'IDLE';
                this.handData = [null, null];
                this.statusEl.classList.remove('show', 'scale', 'rotate', 'reset');
                $('helpBtn').classList.remove('show');
            }
            
            runDetection() {
                if (!this.active || !this.hands || !this.app.vid) return;
                const detect = async () => {
                    if (!this.active) return;
                    if (this.app.vid.readyState >= 2) {
                        try { await this.hands.send({ image: this.app.vid }); } catch(e) {}
                    }
                    if (this.active) requestAnimationFrame(detect);
                };
                detect();
            }
            
            onResults(results) {
                if (!this.active) return;
                
                const ctx = this.app.ctx;
                const ovr = this.app.ovr;
                if (ctx) ctx.clearRect(0, 0, ovr.width, ovr.height);
                
                this.handsDetected = results.multiHandLandmarks ? results.multiHandLandmarks.length : 0;
                setDebug('dHands', this.handsDetected);
                this.handData = [null, null];
                
                if (this.handsDetected === 0) {
                    this.handleNoHands();
                    return;
                }
                
                for (let i = 0; i < this.handsDetected; i++) {
                    this.handData[i] = this.analyzeHand(results.multiHandLandmarks[i]);
                }
                
                if (this.handsDetected === 2 && this.handData[0] && this.handData[1]) {
                    if (this.handData[0].centerX > this.handData[1].centerX) {
                        [this.handData[0], this.handData[1]] = [this.handData[1], this.handData[0]];
                    }
                }
                
                this.drawHands(ctx, ovr);
                const gesture = this.detectGesture();
                this.applyStability(gesture);
                this.executeAction();
            }
            
            analyzeHand(landmarks) {
                if (!landmarks || landmarks.length < 21) return null;
                const lm = landmarks;
                
                const dist = (a, b) => Math.sqrt(Math.pow(lm[a].x - lm[b].x, 2) + Math.pow(lm[a].y - lm[b].y, 2));
                
                let cx = 0, cy = 0;
                [0, 5, 9, 13, 17].forEach(i => { cx += lm[i].x; cy += lm[i].y; });
                cx /= 5; cy /= 5;
                
                const isExtended = (tip, pip, mcp) => {
                    const tipToWrist = dist(tip, 0);
                    const mcpToWrist = dist(mcp, 0);
                    return tipToWrist > mcpToWrist * 0.9;
                };
                
                const extCount = [
                    isExtended(8, 6, 5),
                    isExtended(12, 10, 9),
                    isExtended(16, 14, 13),
                    isExtended(20, 18, 17)
                ].filter(Boolean).length;
                
                const pinchDist = dist(4, 8);
                const isPinching = pinchDist < 0.09;
                const pinchPoint = { x: (lm[4].x + lm[8].x) / 2, y: (lm[4].y + lm[8].y) / 2 };
                const thumbAway = dist(4, 5) > 0.1;
                const isOpen = extCount >= 3 && thumbAway && pinchDist > 0.12;
                const isFist = (4 - extCount) >= 3 && !isPinching;
                
                return { landmarks: lm, centerX: cx, centerY: cy, isPinching, pinchPoint, isOpen, isFist };
            }
            
            detectGesture() {
                const [h0, h1] = this.handData;
                
                if (this.handsDetected === 2 && h0 && h1) {
                    if (h0.isOpen && h1.isOpen) return 'TWO_HAND_EXIT';
                    if (h0.isPinching && h1.isPinching) return 'TWO_HAND_SCALE';
                    return 'TWO_HAND_TRACKING';
                }
                
                if (this.handsDetected === 1 && h0) {
                    this.prevHandCenter = { ...this.handCenter };
                    this.handCenter = { x: h0.centerX, y: h0.centerY };
                    if (h0.isFist) return 'FIST_ROTATE';
                    return 'TRACKING';
                }
                
                return 'IDLE';
            }
            
            applyStability(gesture) {
                const now = Date.now();
                if (gesture !== this.stableState) {
                    this.stableState = gesture;
                    this.stableStateStart = now;
                    return;
                }
                if (now - this.stableStateStart >= this.requiredStableTime && gesture !== this.state) {
                    this.enterState(gesture);
                }
            }
            
            enterState(newState) {
                this.state = newState;
                this.stateStartTime = Date.now();
                this.statusEl.classList.remove('scale', 'rotate', 'reset');
                this.progressEl.style.setProperty('--progress', '0%');
                
                switch (newState) {
                    case 'IDLE':
                        this.showStatus('üëã', 'Show hands');
                        break;
                    case 'TRACKING':
                        this.showStatus('‚úã', 'Tracking');
                        break;
                    case 'FIST_ROTATE':
                        this.showStatus('‚úä', 'Rotate');
                        this.statusEl.classList.add('rotate');
                        break;
                    case 'TWO_HAND_SCALE':
                        this.enterScaleMode();
                        break;
                    case 'TWO_HAND_EXIT':
                        this.twoHandOpenStart = Date.now();
                        this.showStatus('‚úã‚úã', 'Hold to reset');
                        this.statusEl.classList.add('reset');
                        break;
                }
            }
            
            enterScaleMode() {
                const [h0, h1] = this.handData;
                if (h0 && h1) {
                    const dx = h1.pinchPoint.x - h0.pinchPoint.x;
                    const dy = h1.pinchPoint.y - h0.pinchPoint.y;
                    this.scaleStartDistance = Math.sqrt(dx*dx + dy*dy) || 0.3;
                    this.scaleStartValue = this.app.obj ? this.app.obj.scale.x : 1;
                }
                this.showStatus('üëåüëå', 'Scale');
                this.statusEl.classList.add('scale');
            }
            
            handleNoHands() {
                if (this.state !== 'IDLE' && Date.now() - this.stableStateStart > 300) {
                    this.enterState('IDLE');
                }
            }
            
            executeAction() {
                switch (this.state) {
                    case 'FIST_ROTATE': this.applyRotation(); break;
                    case 'TWO_HAND_SCALE': this.applyScale(); break;
                    case 'TWO_HAND_EXIT': this.checkReset(); break;
                }
            }
            
            applyRotation() {
                const dx = this.handCenter.x - this.prevHandCenter.x;
                const dy = this.handCenter.y - this.prevHandCenter.y;
                if (Math.abs(dx) < 0.003 && Math.abs(dy) < 0.003) return;
                this.app.modelRotation.y += dx * 3;
                this.app.modelRotation.x += dy * 3;
            }
            
            applyScale() {
                const [h0, h1] = this.handData;
                if (!h0 || !h1 || !this.app.obj || this.scaleStartDistance < 0.01) return;
                
                const dx = h1.pinchPoint.x - h0.pinchPoint.x;
                const dy = h1.pinchPoint.y - h0.pinchPoint.y;
                const dist = Math.sqrt(dx*dx + dy*dy);
                const ratio = dist / this.scaleStartDistance;
                const newScale = Math.max(0.2, Math.min(4, this.scaleStartValue * ratio));
                
                this.app.obj.scale.setScalar(newScale);
                const pct = Math.round(newScale * 100);
                const arrow = ratio > 1.05 ? ' ‚Üë' : ratio < 0.95 ? ' ‚Üì' : '';
                this.showStatus('üëåüëå', `${pct}%${arrow}`);
            }
            
            checkReset() {
                const elapsed = Date.now() - this.twoHandOpenStart;
                const progress = Math.min(100, (elapsed / 2000) * 100);
                this.progressEl.style.setProperty('--progress', `${progress}%`);
                
                if (elapsed >= 2000) {
                    this.app.resetRotation();
                    if (this.app.obj) this.app.obj.scale.setScalar(1);
                    this.showStatus('‚Ü∫', 'Reset!');
                    this.twoHandOpenStart = Date.now() + 1000;
                    setTimeout(() => {
                        if (this.state === 'TWO_HAND_EXIT') this.showStatus('‚úã‚úã', 'Hold to reset');
                    }, 500);
                }
            }
            
            showStatus(icon, text) {
                this.statusIcon.textContent = icon;
                this.statusText.textContent = text;
            }
            
            drawHands(ctx, ovr) {
                if (!ctx) return;
                const w = ovr.width, h = ovr.height;
                ctx.save();
                ctx.translate(w, 0);
                ctx.scale(-1, 1);
                
                for (let i = 0; i < this.handsDetected; i++) {
                    const hand = this.handData[i];
                    if (!hand) continue;
                    const lm = hand.landmarks;
                    
                    let color = '#666';
                    if (hand.isFist) color = '#ff6a00';
                    else if (hand.isPinching) color = '#00ff88';
                    else if (hand.isOpen) color = '#ff4466';
                    
                    const conns = [[0,1],[1,2],[2,3],[3,4],[0,5],[5,6],[6,7],[7,8],[0,9],[9,10],[10,11],[11,12],[0,13],[13,14],[14,15],[15,16],[0,17],[17,18],[18,19],[19,20],[5,9],[9,13],[13,17]];
                    ctx.strokeStyle = color;
                    ctx.lineWidth = 2;
                    conns.forEach(([a,b]) => {
                        ctx.beginPath();
                        ctx.moveTo(lm[a].x * w, lm[a].y * h);
                        ctx.lineTo(lm[b].x * w, lm[b].y * h);
                        ctx.stroke();
                    });
                    
                    lm.forEach((pt, idx) => {
                        ctx.beginPath();
                        ctx.arc(pt.x * w, pt.y * h, [4,8,12,16,20].includes(idx) ? 4 : 2, 0, Math.PI*2);
                        ctx.fillStyle = '#fff';
                        ctx.fill();
                    });
                    
                    if (hand.isPinching) {
                        ctx.beginPath();
                        ctx.arc(hand.pinchPoint.x * w, hand.pinchPoint.y * h, 6, 0, Math.PI*2);
                        ctx.fillStyle = '#00ff88';
                        ctx.fill();
                    }
                }
                
                if (this.state === 'TWO_HAND_SCALE' && this.handData[0] && this.handData[1]) {
                    const [h0, h1] = this.handData;
                    ctx.setLineDash([4, 4]);
                    ctx.strokeStyle = '#00ff88';
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    ctx.moveTo(h0.pinchPoint.x * w, h0.pinchPoint.y * h);
                    ctx.lineTo(h1.pinchPoint.x * w, h1.pinchPoint.y * h);
                    ctx.stroke();
                    ctx.setLineDash([]);
                }
                
                ctx.restore();
            }
        }
        
        // ============ MAIN APP ============
        class App {
            constructor() {
                this.vid = $('vid');
                this.ovr = $('ovr');
                this.ctx = null;
                
                this.scene = null;
                this.camera = null;
                this.renderer = null;
                this.obj = null;
                this.tesseract = null;
                this.particles = null;
                
                this.face = { x: 0, y: 0, z: 400 };
                this.smooth = { x: 0, y: 0, z: 400 };
                this.tracking = false;
                
                this.mode = 'view';
                this.modelRotation = { x: 0, y: 0, z: 0 };
                this.baseRotation = { x: 0, y: 0, z: 0 };
                
                this.handController = null;
                this.detector = null;
                
                this.lastTime = performance.now();
                
                this.init();
            }
            
            async init() {
                this.setup3D();
                await this.setupCamera();
                await this.setupTracking();
                this.handController = new HandController(this);
                await this.handController.init();
                this.setupUI();
                this.animate();
                log('App ready', 'ok');
            }
            
            setup3D() {
                const canvas = $('canvas3d');
                this.scene = new THREE.Scene();
                this.scene.fog = new THREE.FogExp2(0x08080c, 0.0015);
                
                this.camera = new THREE.PerspectiveCamera(60, innerWidth/innerHeight, 1, 5000);
                this.camera.position.z = 400;
                
                this.renderer = new THREE.WebGLRenderer({ canvas, antialias: true });
                this.renderer.setSize(innerWidth, innerHeight);
                this.renderer.setPixelRatio(Math.min(devicePixelRatio, 2));
                this.renderer.setClearColor(0x08080c);
                
                // Lighting
                this.scene.add(new THREE.AmbientLight(0xffffff, 0.3));
                const keyLight = new THREE.DirectionalLight(0xffffff, 0.8);
                keyLight.position.set(50, 100, 100);
                this.scene.add(keyLight);
                const rimLight = new THREE.DirectionalLight(0x00f0ff, 0.4);
                rimLight.position.set(-50, -50, -100);
                this.scene.add(rimLight);
                const accentLight = new THREE.PointLight(0xff6a00, 0.5, 800);
                accentLight.position.set(0, 150, -200);
                this.scene.add(accentLight);
                
                this.createRoom();
                this.createParticles();
                this.makeObj('cube');
            }
            
            createRoom() {
                const room = new THREE.Group();
                const gc = 0xff6a00, gd = 0x1a0a00;
                const D = 500, W = 400, H = 300;
                
                // Floor with gradient opacity (brighter near, dimmer far)
                const floor = new THREE.GridHelper(W*2, 32, gc, gd);
                floor.position.set(0, -H/2, -D/2);
                floor.material.transparent = true;
                floor.material.opacity = 0.6;
                room.add(floor);
                
                // Back wall
                const back = new THREE.GridHelper(W*2, 32, gc, gd);
                back.rotation.x = Math.PI/2;
                back.position.z = -D;
                back.material.transparent = true;
                back.material.opacity = 0.4;
                room.add(back);
                
                // Side walls (subtle)
                [-1, 1].forEach(side => {
                    const wall = new THREE.GridHelper(D, 20, gc, gd);
                    wall.rotation.z = Math.PI/2;
                    wall.position.set(side * W, 0, -D/2);
                    wall.material.transparent = true;
                    wall.material.opacity = 0.2;
                    room.add(wall);
                });
                
                // Ceiling (very subtle)
                const ceil = new THREE.GridHelper(W*2, 32, gc, gd);
                ceil.position.set(0, H/2, -D/2);
                ceil.material.transparent = true;
                ceil.material.opacity = 0.08;
                room.add(ceil);
                
                // Corner edge lines
                const edgeMat = new THREE.LineBasicMaterial({ color: gc, transparent: true, opacity: 0.4 });
                [[-W,-H/2], [W,-H/2], [-W,H/2], [W,H/2]].forEach(([x,y]) => {
                    const geo = new THREE.BufferGeometry().setFromPoints([
                        new THREE.Vector3(x, y, 0),
                        new THREE.Vector3(x, y, -D)
                    ]);
                    room.add(new THREE.Line(geo, edgeMat));
                });
                
                // Horizon glow line
                const horizonGeo = new THREE.PlaneGeometry(W*3, 6);
                const horizonMat = new THREE.MeshBasicMaterial({
                    color: gc,
                    transparent: true,
                    opacity: 0.8
                });
                const horizon = new THREE.Mesh(horizonGeo, horizonMat);
                horizon.position.set(0, -H/2 + 3, -D + 2);
                room.add(horizon);
                
                // Ground glow plane
                const glowGeo = new THREE.PlaneGeometry(W*2, D);
                const glowMat = new THREE.MeshBasicMaterial({
                    color: gc,
                    transparent: true,
                    opacity: 0.05,
                    side: THREE.DoubleSide
                });
                const glow = new THREE.Mesh(glowGeo, glowMat);
                glow.rotation.x = -Math.PI/2;
                glow.position.set(0, -H/2 + 1, -D/2);
                room.add(glow);
                
                this.scene.add(room);
            }
            
            createParticles() {
                const count = 100;
                const positions = new Float32Array(count * 3);
                
                for (let i = 0; i < count; i++) {
                    positions[i*3] = (Math.random() - 0.5) * 800;
                    positions[i*3+1] = (Math.random() - 0.5) * 400;
                    positions[i*3+2] = -Math.random() * 500;
                }
                
                const geo = new THREE.BufferGeometry();
                geo.setAttribute('position', new THREE.BufferAttribute(positions, 3));
                
                const mat = new THREE.PointsMaterial({
                    color: 0xff6a00,
                    size: 2,
                    transparent: true,
                    opacity: 0.4,
                    sizeAttenuation: true
                });
                
                this.particles = new THREE.Points(geo, mat);
                this.scene.add(this.particles);
            }
            
            makeObj(type) {
                if (this.obj) this.scene.remove(this.obj);
                this.tesseract = null;
                $('modelInfo').classList.remove('show');
                
                this.modelRotation = { x: 0, y: 0, z: 0 };
                this.baseRotation = { x: 0, y: 0, z: 0 };
                
                if (type === 'cube') {
                    const g = new THREE.Group();
                    
                    // Solid cube with nice material
                    const cube = new THREE.Mesh(
                        new THREE.BoxGeometry(90, 90, 90),
                        new THREE.MeshPhysicalMaterial({
                            color: 0xff6a00,
                            metalness: 0.3,
                            roughness: 0.4,
                            clearcoat: 0.5
                        })
                    );
                    g.add(cube);
                    
                    // Wireframe overlay for depth
                    const wire = new THREE.Mesh(
                        new THREE.BoxGeometry(92, 92, 92),
                        new THREE.MeshBasicMaterial({
                            color: 0xffffff,
                            wireframe: true,
                            transparent: true,
                            opacity: 0.15
                        })
                    );
                    g.add(wire);
                    
                    // Edge glow
                    const edges = new THREE.EdgesGeometry(new THREE.BoxGeometry(90, 90, 90));
                    const edgeLine = new THREE.LineSegments(
                        edges,
                        new THREE.LineBasicMaterial({ color: 0x00f0ff, transparent: true, opacity: 0.4 })
                    );
                    g.add(edgeLine);
                    
                    g.position.z = -80;
                    this.obj = g;
                    
                } else if (type === 'tesseract') {
                    this.tesseract = new Tesseract();
                    this.obj = this.tesseract.group;
                    
                } else if (type === 'torus') {
                    const g = new THREE.Group();
                    const knot = new THREE.Mesh(
                        new THREE.TorusKnotGeometry(50, 15, 100, 16),
                        new THREE.MeshPhysicalMaterial({
                            color: 0xff6a00,
                            metalness: 0.3,
                            roughness: 0.4,
                            clearcoat: 0.5
                        })
                    );
                    g.add(knot);
                    
                    // Wireframe overlay
                    const wire = new THREE.Mesh(
                        new THREE.TorusKnotGeometry(50, 15, 100, 16),
                        new THREE.MeshBasicMaterial({ color: 0x00f0ff, wireframe: true, transparent: true, opacity: 0.1 })
                    );
                    g.add(wire);
                    
                    g.position.z = -80;
                    this.obj = g;
                    
                } else if (type === 'gem') {
                    const g = new THREE.Group();
                    const gem = new THREE.Mesh(
                        new THREE.OctahedronGeometry(60, 0),
                        new THREE.MeshPhysicalMaterial({
                            color: 0x00f0ff,
                            metalness: 0.1,
                            roughness: 0.1,
                            clearcoat: 1,
                            transparent: true,
                            opacity: 0.9
                        })
                    );
                    g.add(gem);
                    
                    // Orbiting rings
                    [0xff6a00, 0x00f0ff, 0xff4466].forEach((c, i) => {
                        const ring = new THREE.Mesh(
                            new THREE.TorusGeometry(80 + i*20, 1.5, 8, 64),
                            new THREE.MeshBasicMaterial({ color: c, transparent: true, opacity: 0.6 })
                        );
                        ring.rotation.x = Math.PI/2 + i*0.4;
                        ring.rotation.y = i*0.5;
                        ring.userData.speed = 0.008 + i*0.004;
                        g.add(ring);
                    });
                    
                    g.position.z = -80;
                    this.obj = g;
                }
                
                if (this.obj) this.scene.add(this.obj);
            }
            
            loadModel(file) {
                const ext = file.name.split('.').pop().toLowerCase();
                $('loading').classList.add('show');
                $('loadTxt').textContent = `Loading ${file.name}...`;
                
                const reader = new FileReader();
                reader.onload = (e) => {
                    try {
                        const geo = ext === 'obj' 
                            ? parseOBJ(typeof e.target.result === 'string' ? e.target.result : new TextDecoder().decode(e.target.result))
                            : parseSTL(e.target.result);
                        
                        geo.computeBoundingBox();
                        const box = geo.boundingBox;
                        const center = new THREE.Vector3();
                        box.getCenter(center);
                        geo.translate(-center.x, -center.y, -center.z);
                        
                        const size = new THREE.Vector3();
                        box.getSize(size);
                        const scale = 120 / Math.max(size.x, size.y, size.z);
                        geo.scale(scale, scale, scale);
                        geo.computeVertexNormals();
                        
                        if (this.obj) this.scene.remove(this.obj);
                        this.tesseract = null;
                        
                        const mat = new THREE.MeshPhysicalMaterial({
                            color: 0xff6a00,
                            metalness: 0.3,
                            roughness: 0.4,
                            clearcoat: 0.3,
                            side: THREE.DoubleSide
                        });
                        
                        const mesh = new THREE.Mesh(geo, mat);
                        const group = new THREE.Group();
                        group.add(mesh);
                        group.position.z = -80;
                        
                        this.modelRotation = { x: 0, y: 0, z: 0 };
                        this.baseRotation = { x: 0, y: 0, z: 0 };
                        this.obj = group;
                        this.scene.add(this.obj);
                        
                        $('modelName').textContent = file.name;
                        $('modelMeta').textContent = `${Math.round(geo.attributes.position.count/3)} faces`;
                        $('modelInfo').classList.add('show');
                        document.querySelectorAll('.obj-btn').forEach(b => b.classList.remove('active'));
                        
                        $('loading').classList.remove('show');
                    } catch (err) {
                        $('loading').classList.remove('show');
                        alert('Error loading model: ' + err.message);
                    }
                };
                reader.onerror = () => {
                    $('loading').classList.remove('show');
                    alert('Error reading file');
                };
                ext === 'obj' ? reader.readAsText(file) : reader.readAsArrayBuffer(file);
            }
            
            async setupCamera() {
                setDebug('dCam', '...', '');
                try {
                    const stream = await navigator.mediaDevices.getUserMedia({
                        video: { facingMode: 'user', width: { ideal: 320 }, height: { ideal: 240 } },
                        audio: false
                    });
                    this.vid.srcObject = stream;
                    await new Promise((res, rej) => {
                        this.vid.onloadedmetadata = () => {
                            this.ovr.width = this.vid.videoWidth;
                            this.ovr.height = this.vid.videoHeight;
                            this.ctx = this.ovr.getContext('2d');
                            this.vid.play().then(res).catch(rej);
                        };
                        setTimeout(() => rej(new Error('Timeout')), 8000);
                    });
                    setDebug('dCam', 'OK', 'ok');
                    $('pipStatus').textContent = 'READY';
                    $('pipStatus').classList.remove('off');
                } catch (err) {
                    setDebug('dCam', 'FAIL', 'err');
                    $('pipStatus').textContent = 'NO CAM';
                    $('pipStatus').classList.add('off');
                    this.setupTouchFallback();
                }
            }
            
            setupTouchFallback() {
                setDebug('dTrack', 'Touch', '');
                const update = (x, y) => {
                    if (this.mode !== 'view') return;
                    this.face.x = -((x/innerWidth) - 0.5) * 400;
                    this.face.y = -((y/innerHeight) - 0.5) * 300;
                    this.tracking = true;
                };
                document.addEventListener('mousemove', e => update(e.clientX, e.clientY));
                document.addEventListener('touchmove', e => {
                    if (e.touches.length === 1) update(e.touches[0].clientX, e.touches[0].clientY);
                }, { passive: true });
            }
            
            async setupTracking() {
                if (!this.vid.srcObject) {
                    setDebug('dTrack', 'None', 'err');
                    return;
                }
                
                setDebug('dTrack', '...', '');
                
                if (typeof FaceDetection !== 'undefined') {
                    try {
                        this.detector = new FaceDetection({
                            locateFile: f => `https://cdn.jsdelivr.net/npm/@mediapipe/face_detection/${f}`
                        });
                        this.detector.setOptions({ model: 'short', minDetectionConfidence: 0.5 });
                        this.detector.onResults(r => this.onFace(r));
                        setDebug('dTrack', 'Face', 'ok');
                        this.runFaceDetection();
                        return;
                    } catch (err) {
                        log(`Face detection failed: ${err.message}`, 'w');
                    }
                }
                
                setDebug('dTrack', 'Basic', '');
                this.setupTouchFallback();
            }
            
            runFaceDetection() {
                const detect = async () => {
                    if (this.detector && this.vid.readyState >= 2 && this.mode === 'view') {
                        try { await this.detector.send({ image: this.vid }); } catch(e) {}
                    }
                    requestAnimationFrame(detect);
                };
                detect();
            }
            
            onFace(results) {
                if (this.mode !== 'view') return;
                
                if (results.detections && results.detections.length > 0) {
                    const b = results.detections[0].boundingBox;
                    this.face.x = -(b.xCenter - 0.5) * 2 * 250;
                    this.face.y = -(b.yCenter - 0.5) * 2 * 180;
                    const fSize = Math.max(b.width, b.height);
                    this.face.z = Math.max(200, Math.min(700, 350 / Math.max(0.15, fSize)));
                    this.tracking = true;
                    $('rec').classList.add('on');
                    $('pipStatus').textContent = 'TRACKING';
                } else {
                    this.tracking = false;
                    $('rec').classList.remove('on');
                    $('pipStatus').textContent = 'SEARCHING';
                }
            }
            
            setMode(mode) {
                this.mode = mode;
                setDebug('dMode', mode.toUpperCase());
                
                document.querySelectorAll('.mode-btn').forEach(b => {
                    b.classList.remove('active');
                    if (b.dataset.mode === mode) b.classList.add('active');
                });
                
                if (mode === 'view') {
                    document.querySelector('.mode-btn[data-mode="view"]').classList.remove('edit');
                    $('objectSelector').classList.remove('hidden');
                    $('pip').classList.remove('edit-mode');
                    if (this.handController) this.handController.stop();
                } else {
                    document.querySelector('.mode-btn[data-mode="edit"]').classList.add('edit');
                    $('objectSelector').classList.add('hidden');
                    $('pip').classList.add('edit-mode');
                    if (this.handController && this.handController.ready) {
                        this.handController.start();
                    }
                }
            }
            
            resetRotation() {
                this.modelRotation = { x: 0, y: 0, z: 0 };
            }
            
            setupUI() {
                // Object selector
                document.querySelectorAll('.obj-btn[data-obj]').forEach(btn => {
                    btn.onclick = () => {
                        document.querySelectorAll('.obj-btn').forEach(b => b.classList.remove('active'));
                        btn.classList.add('active');
                        this.makeObj(btn.dataset.obj);
                    };
                });
                
                // Upload
                $('uploadBtn').onclick = () => $('fileInput').click();
                $('fileInput').onchange = (e) => {
                    if (e.target.files[0]) this.loadModel(e.target.files[0]);
                    e.target.value = '';
                };
                
                // Clear model
                $('clearModel').onclick = () => {
                    this.makeObj('cube');
                    document.querySelector('.obj-btn[data-obj="cube"]').classList.add('active');
                };
                
                // Mode toggle
                document.querySelectorAll('.mode-btn').forEach(btn => {
                    btn.onclick = () => this.setMode(btn.dataset.mode);
                });
                
                // Debug toggle
                $('debugToggle').onclick = () => {
                    $('debugPanel').classList.toggle('show');
                    $('debugToggle').classList.toggle('active');
                };
                
                // Help
                $('helpBtn').onclick = () => $('gestureHelp').classList.add('show');
                $('closeHelp').onclick = () => $('gestureHelp').classList.remove('show');
                
                // Resize
                window.addEventListener('resize', () => {
                    this.camera.aspect = innerWidth / innerHeight;
                    this.camera.updateProjectionMatrix();
                    this.renderer.setSize(innerWidth, innerHeight);
                });
                
                // Touch rotation in edit mode
                this.setupTouchRotation();
            }
            
            setupTouchRotation() {
                const canvas = $('canvas3d');
                let touchStart = null;
                
                canvas.addEventListener('touchstart', (e) => {
                    if (this.mode !== 'edit' || e.touches.length !== 2) return;
                    e.preventDefault();
                    const [t1, t2] = [e.touches[0], e.touches[1]];
                    touchStart = {
                        x: (t1.clientX + t2.clientX) / 2,
                        y: (t1.clientY + t2.clientY) / 2,
                        rotX: this.modelRotation.x,
                        rotY: this.modelRotation.y
                    };
                }, { passive: false });
                
                canvas.addEventListener('touchmove', (e) => {
                    if (!touchStart || e.touches.length !== 2) return;
                    e.preventDefault();
                    const [t1, t2] = [e.touches[0], e.touches[1]];
                    const cx = (t1.clientX + t2.clientX) / 2;
                    const cy = (t1.clientY + t2.clientY) / 2;
                    this.modelRotation.y = touchStart.rotY + (cx - touchStart.x) * 0.01;
                    this.modelRotation.x = touchStart.rotX + (cy - touchStart.y) * 0.01;
                }, { passive: false });
                
                canvas.addEventListener('touchend', () => { touchStart = null; });
                
                // Mouse fallback
                let mouseDown = false, mouseStart = null;
                canvas.addEventListener('mousedown', (e) => {
                    if (this.mode !== 'edit') return;
                    mouseDown = true;
                    mouseStart = { x: e.clientX, y: e.clientY, rotX: this.modelRotation.x, rotY: this.modelRotation.y };
                });
                canvas.addEventListener('mousemove', (e) => {
                    if (!mouseDown || !mouseStart) return;
                    this.modelRotation.y = mouseStart.rotY + (e.clientX - mouseStart.x) * 0.005;
                    this.modelRotation.x = mouseStart.rotX + (e.clientY - mouseStart.y) * 0.005;
                });
                canvas.addEventListener('mouseup', () => { mouseDown = false; });
                canvas.addEventListener('mouseleave', () => { mouseDown = false; });
            }
            
            updateProjection() {
                if (this.mode === 'view') {
                    this.smooth.x += (this.face.x - this.smooth.x) * 0.1;
                    this.smooth.y += (this.face.y - this.smooth.y) * 0.1;
                    this.smooth.z += (this.face.z - this.smooth.z) * 0.1;
                }
                
                const { x, y, z } = this.smooth;
                const asp = innerWidth / innerHeight;
                const hw = 180, hh = hw / asp;
                const n = 10, f = 3000, r = n / z;
                
                this.camera.projectionMatrix.makePerspective(
                    (-hw - x) * r, (hw - x) * r,
                    (hh - y) * r, (-hh - y) * r,
                    n, f
                );
                this.camera.projectionMatrixInverse.copy(this.camera.projectionMatrix).invert();
                this.camera.position.set(x, y, z);
                this.camera.lookAt(x, y, -200);
            }
            
            animate() {
                requestAnimationFrame(() => this.animate());
                
                const now = performance.now();
                const dt = (now - this.lastTime) / 1000;
                this.lastTime = now;
                
                updateFPS();
                this.updateProjection();
                
                // Update tesseract
                if (this.tesseract) {
                    this.tesseract.update(dt);
                }
                
                // Update particles
                if (this.particles) {
                    const pos = this.particles.geometry.attributes.position.array;
                    for (let i = 0; i < pos.length; i += 3) {
                        pos[i + 2] += dt * 20;
                        if (pos[i + 2] > 0) pos[i + 2] = -500;
                    }
                    this.particles.geometry.attributes.position.needsUpdate = true;
                }
                
                // Apply rotation to object
                if (this.obj && !this.tesseract) {
                    this.obj.rotation.x = this.baseRotation.x + this.modelRotation.x;
                    this.obj.rotation.y = this.baseRotation.y + this.modelRotation.y;
                    this.obj.rotation.z = this.baseRotation.z + this.modelRotation.z;
                    
                    // Animate gem rings
                    this.obj.children.forEach(c => {
                        if (c.userData && c.userData.speed) {
                            c.rotation.z += c.userData.speed;
                        }
                    });
                }
                
                this.renderer.render(this.scene, this.camera);
            }
        }
        
        // Start
        new App();
    })();
    </script>
</body>
</html>
