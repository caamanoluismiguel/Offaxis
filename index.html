<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <title>OffAxis 3D + STL</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            background: #000;
            overflow: hidden;
            font-family: -apple-system, sans-serif;
            touch-action: none;
        }
        #canvas3d {
            width: 100vw;
            height: 100vh;
            display: block;
        }
        
        /* PIP */
        #pip {
            position: fixed;
            bottom: 20px;
            right: 20px;
            width: 100px;
            height: 130px;
            border-radius: 10px;
            overflow: hidden;
            z-index: 100;
            background: #000;
            border: 2px solid rgba(255,102,0,0.5);
            transition: opacity 0.3s, border-color 0.3s;
        }
        #pip.paused {
            opacity: 0.4;
            border-color: rgba(255,255,255,0.3);
        }
        #pip video {
            width: 100%;
            height: 100%;
            object-fit: cover;
            transform: scaleX(-1);
        }
        #pip canvas {
            position: absolute;
            top: 0; left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
        }
        #dot {
            position: absolute;
            top: 6px; left: 6px;
            width: 8px; height: 8px;
            border-radius: 50%;
            background: #ff3b30;
        }
        #dot.on { background: #30d158; box-shadow: 0 0 8px #30d158; }
        
        /* Status panel */
        #status {
            position: fixed;
            top: 10px;
            right: 10px;
            background: rgba(0,0,0,0.85);
            border: 1px solid #333;
            border-radius: 8px;
            padding: 10px;
            font-size: 10px;
            color: #fff;
            z-index: 100;
            min-width: 120px;
            font-family: monospace;
        }
        #status div { margin: 3px 0; display: flex; justify-content: space-between; gap: 10px; }
        #status .v { color: #ff6600; }
        #status .ok { color: #30d158; }
        #status .err { color: #ff3b30; }
        
        /* Objects panel */
        #objs {
            position: fixed;
            left: 16px;
            top: 50%;
            transform: translateY(-50%);
            display: flex;
            flex-direction: column;
            gap: 10px;
            z-index: 100;
        }
        .ob {
            width: 46px; height: 46px;
            border-radius: 12px;
            border: none;
            background: rgba(255,255,255,0.08);
            color: #fff;
            font-size: 20px;
            cursor: pointer;
        }
        .ob.on { 
            background: rgba(255,102,0,0.25); 
            box-shadow: 0 0 0 2px #ff6600;
        }
        
        /* Upload button */
        #uploadBtn {
            width: 46px; height: 46px;
            border-radius: 12px;
            border: 2px dashed rgba(255,102,0,0.5);
            background: rgba(255,102,0,0.1);
            color: #ff6600;
            font-size: 20px;
            cursor: pointer;
        }
        #uploadBtn:active {
            background: rgba(255,102,0,0.3);
        }
        
        /* Mode Toggle Button */
        #modeToggle {
            position: fixed;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(255,102,0,0.9);
            border: none;
            border-radius: 25px;
            padding: 12px 24px;
            color: #fff;
            font-size: 14px;
            font-weight: 600;
            cursor: pointer;
            z-index: 200;
            display: flex;
            align-items: center;
            gap: 8px;
            box-shadow: 0 4px 20px rgba(255,102,0,0.4);
            transition: all 0.3s;
        }
        #modeToggle:active {
            transform: translateX(-50%) scale(0.95);
        }
        #modeToggle.edit {
            background: rgba(0,200,100,0.9);
            box-shadow: 0 4px 20px rgba(0,200,100,0.4);
        }
        #modeToggle .icon {
            font-size: 18px;
        }
        
        /* Rotation Controls Panel */
        #rotControls {
            position: fixed;
            bottom: 80px;
            left: 50%;
            transform: translateX(-50%) translateY(20px);
            background: rgba(0,0,0,0.9);
            border: 1px solid rgba(0,200,100,0.5);
            border-radius: 16px;
            padding: 12px 16px;
            z-index: 150;
            display: flex;
            flex-direction: column;
            gap: 10px;
            opacity: 0;
            pointer-events: none;
            transition: all 0.3s;
        }
        #rotControls.show {
            opacity: 1;
            pointer-events: auto;
            transform: translateX(-50%) translateY(0);
        }
        #rotControls .row {
            display: flex;
            gap: 8px;
            align-items: center;
            justify-content: center;
        }
        #rotControls .axis-label {
            color: #888;
            font-size: 11px;
            width: 20px;
            text-align: center;
            font-weight: 600;
        }
        #rotControls button {
            width: 44px;
            height: 36px;
            border: none;
            border-radius: 8px;
            background: rgba(255,255,255,0.1);
            color: #fff;
            font-size: 12px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.15s;
        }
        #rotControls button:active {
            transform: scale(0.92);
            background: rgba(255,255,255,0.2);
        }
        #rotControls button.rot-x { border-bottom: 2px solid #ff4444; }
        #rotControls button.rot-y { border-bottom: 2px solid #44ff44; }
        #rotControls button.rot-z { border-bottom: 2px solid #4488ff; }
        #rotControls button.reset {
            background: rgba(255,102,0,0.3);
            border-bottom: 2px solid #ff6600;
            width: auto;
            padding: 0 16px;
        }
        
        /* Edit mode hint */
        #editHint {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0,0,0,0.8);
            border: 1px solid rgba(0,200,100,0.5);
            border-radius: 12px;
            padding: 16px 24px;
            color: #fff;
            font-size: 13px;
            text-align: center;
            z-index: 100;
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.3s;
        }
        #editHint.show {
            opacity: 1;
        }
        #editHint .gesture {
            font-size: 28px;
            margin-bottom: 8px;
        }
        
        /* Gesture status badge */
        #gestureStatus {
            position: fixed;
            bottom: 140px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0,0,0,0.9);
            border: 2px solid #444;
            border-radius: 20px;
            padding: 8px 16px;
            color: #fff;
            font-size: 13px;
            z-index: 160;
            display: none;
            align-items: center;
            gap: 8px;
            min-width: 140px;
            justify-content: center;
            transition: all 0.2s;
        }
        #gestureStatus.show { display: flex; }
        #gestureStatus.fist { border-color: #ff6600; background: rgba(255,102,0,0.2); }
        #gestureStatus.pinch { border-color: #00ff88; background: rgba(0,255,136,0.2); }
        #gestureStatus.palm { border-color: #ff4488; background: rgba(255,68,136,0.2); }
        #gestureStatus .icon { font-size: 18px; }
        #gestureStatus .progress {
            position: absolute;
            bottom: 0;
            left: 10px;
            right: 10px;
            height: 3px;
            background: rgba(255,255,255,0.2);
            border-radius: 2px;
            overflow: hidden;
        }
        #gestureStatus .progress::after {
            content: '';
            position: absolute;
            left: 0;
            top: 0;
            height: 100%;
            width: var(--progress, 0%);
            background: #ff4488;
            transition: width 0.1s;
        }
        
        /* Gesture help overlay */
        #gestureHelp {
            position: fixed;
            inset: 0;
            background: rgba(0,0,0,0.85);
            display: none;
            align-items: center;
            justify-content: center;
            z-index: 600;
        }
        #gestureHelp.show { display: flex; }
        #gestureHelp .help-content {
            background: #1a1a1a;
            border: 1px solid #333;
            border-radius: 16px;
            padding: 24px;
            text-align: center;
            max-width: 280px;
        }
        #gestureHelp h3 {
            color: #fff;
            margin: 0 0 16px 0;
            font-size: 18px;
        }
        #gestureHelp .gesture-row {
            display: flex;
            align-items: center;
            gap: 12px;
            padding: 10px 0;
            color: #ccc;
            font-size: 14px;
            border-bottom: 1px solid #333;
        }
        #gestureHelp .gesture-row:last-of-type { border-bottom: none; }
        #gestureHelp .gesture-row span { font-size: 24px; width: 36px; }
        #gestureHelp button {
            margin-top: 20px;
            background: #ff6600;
            border: none;
            border-radius: 20px;
            padding: 10px 24px;
            color: #fff;
            font-size: 14px;
            cursor: pointer;
        }
        
        /* Help button */
        #helpBtn {
            position: fixed;
            bottom: 24px;
            right: 140px;
            width: 36px;
            height: 36px;
            border-radius: 50%;
            border: 2px solid rgba(255,255,255,0.3);
            background: rgba(0,0,0,0.6);
            color: #fff;
            font-size: 16px;
            font-weight: bold;
            cursor: pointer;
            z-index: 150;
            display: none;
        }
        #helpBtn.show { display: block; }
        
        /* Model info */
        #modelInfo {
            position: fixed;
            top: 10px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0,0,0,0.8);
            padding: 8px 16px;
            border-radius: 16px;
            color: #fff;
            font-size: 11px;
            z-index: 100;
            display: none;
            align-items: center;
            gap: 8px;
        }
        #modelInfo.show { display: flex; }
        #modelInfo .name { color: #ff6600; max-width: 120px; overflow: hidden; text-overflow: ellipsis; white-space: nowrap; }
        #modelInfo .close { background: none; border: none; color: #888; font-size: 14px; cursor: pointer; padding: 0; margin-left: 8px; }
        
        /* Loading */
        #loading {
            position: fixed;
            inset: 0;
            background: rgba(0,0,0,0.85);
            display: none;
            align-items: center;
            justify-content: center;
            flex-direction: column;
            z-index: 500;
        }
        #loading.show { display: flex; }
        .spin {
            width: 36px; height: 36px;
            border: 3px solid rgba(255,102,0,0.2);
            border-top-color: #ff6600;
            border-radius: 50%;
            animation: spin 0.8s linear infinite;
        }
        @keyframes spin { to { transform: rotate(360deg); } }
        #loading p { color: #fff; margin-top: 12px; font-size: 13px; }
        
        /* Debug log */
        #debugLog {
            position: fixed;
            bottom: 160px;
            right: 10px;
            width: 140px;
            max-height: 150px;
            background: rgba(0,0,0,0.85);
            border: 1px solid #333;
            border-radius: 8px;
            padding: 8px;
            font-size: 9px;
            font-family: monospace;
            color: #0f0;
            overflow-y: auto;
            z-index: 100;
        }
        #debugLog .e { color: #f55; }
        #debugLog .w { color: #fa0; }
    </style>
</head>
<body>
    <canvas id="canvas3d"></canvas>
    
    <div id="pip">
        <video id="vid" playsinline autoplay muted></video>
        <canvas id="ovr"></canvas>
        <div id="dot"></div>
    </div>
    
    <div id="status">
        <div>Mode <span class="v" id="sMode">VIEW</span></div>
        <div>Cam <span class="v" id="sCam">--</span></div>
        <div>Track <span class="v" id="sTrack">--</span></div>
        <div>Face <span class="v" id="sFace">--</span></div>
        <div>X <span class="v" id="sX">0</span></div>
        <div>Y <span class="v" id="sY">0</span></div>
        <div>Model <span class="v" id="sModel">--</span></div>
    </div>
    
    <div id="debugLog"></div>
    
    <div id="objs">
        <button class="ob on" data-o="sneaker">üëü</button>
        <button class="ob" data-o="cube">üé≤</button>
        <button class="ob" data-o="gem">üíé</button>
        <button id="uploadBtn">üìÅ</button>
        <input type="file" id="fileInput" accept=".stl,.STL,.obj,.OBJ" style="display:none">
    </div>
    
    <div id="modelInfo">
        <span>üì¶</span>
        <span class="name" id="modelName"></span>
        <button class="close" id="clearModel">‚úï</button>
    </div>
    
    <!-- Mode Toggle Button -->
    <button id="modeToggle">
        <span class="icon">üëÅÔ∏è</span>
        <span class="label">VIEW MODE</span>
    </button>
    
    <!-- Rotation Controls (shown in Edit mode) -->
    <div id="rotControls">
        <div class="row">
            <span class="axis-label">X</span>
            <button class="rot-x" data-axis="x" data-dir="-1">-90¬∞</button>
            <button class="rot-x" data-axis="x" data-dir="1">+90¬∞</button>
        </div>
        <div class="row">
            <span class="axis-label">Y</span>
            <button class="rot-y" data-axis="y" data-dir="-1">-90¬∞</button>
            <button class="rot-y" data-axis="y" data-dir="1">+90¬∞</button>
        </div>
        <div class="row">
            <span class="axis-label">Z</span>
            <button class="rot-z" data-axis="z" data-dir="-1">-90¬∞</button>
            <button class="rot-z" data-axis="z" data-dir="1">+90¬∞</button>
        </div>
        <div class="row">
            <button class="reset" id="resetRot">‚Ü∫ Reset</button>
        </div>
    </div>
    
    <!-- Edit mode hint -->
    <div id="editHint">
        <div class="gesture">üëÜüëÜ</div>
        <div>Two-finger drag to rotate</div>
    </div>
    
    <!-- Gesture status badge -->
    <div id="gestureStatus">
        <span class="icon">üëã</span>
        <span class="text">Show hand</span>
        <div class="progress"></div>
    </div>
    
    <!-- Gesture help overlay -->
    <div id="gestureHelp">
        <div class="help-content">
            <h3>‚úã Hand Gestures</h3>
            <div class="gesture-row"><span>‚úä</span> Fist + drag ‚Üí Rotate</div>
            <div class="gesture-row"><span>ü§è</span> Pinch spread ‚Üí Scale</div>
            <div class="gesture-row"><span>‚úã</span> Palm hold 2s ‚Üí Reset</div>
            <button id="closeHelp">Got it!</button>
        </div>
    </div>
    
    <!-- Help button (shown in edit mode) -->
    <button id="helpBtn">?</button>
    
    <div id="loading">
        <div class="spin"></div>
        <p id="loadTxt">Loading...</p>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/face_detection/face_detection.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js" crossorigin="anonymous"></script>
    
    <script>
    (function() {
        'use strict';
        
        // ============ DEBUG SYSTEM ============
        const $ = id => document.getElementById(id);
        const logEl = $('debugLog');
        
        function log(msg, type = '') {
            const d = document.createElement('div');
            d.className = type;
            d.textContent = msg;
            logEl.appendChild(d);
            logEl.scrollTop = logEl.scrollHeight;
            console.log(`[${type||'i'}] ${msg}`);
        }
        
        function stat(id, val, cls) {
            const el = $(id);
            if (el) {
                el.textContent = val;
                el.className = 'v ' + (cls || '');
            }
        }
        
        // ============ STL LOADER ============
        function parseSTL(buffer) {
            log('Parsing STL...');
            
            function isBinary(data) {
                const reader = new DataView(data);
                const faceSize = (32/8*3) + ((32/8*3)*3) + (16/8);
                const nFaces = reader.getUint32(80, true);
                const expect = 80 + (32/8) + (nFaces * faceSize);
                if (expect === reader.byteLength) return true;
                const solid = [115, 111, 108, 105, 100];
                for (let i = 0; i < 5; i++) {
                    if (solid[i] !== reader.getUint8(i)) return true;
                }
                return false;
            }
            
            function parseBinary(data) {
                const reader = new DataView(data);
                const faces = reader.getUint32(80, true);
                log(`Binary STL: ${faces} faces`);
                
                const vertices = new Float32Array(faces * 3 * 3);
                const normals = new Float32Array(faces * 3 * 3);
                
                const dataOffset = 84;
                const faceLength = 12 * 4 + 2;
                
                for (let face = 0; face < faces; face++) {
                    const start = dataOffset + face * faceLength;
                    const nx = reader.getFloat32(start, true);
                    const ny = reader.getFloat32(start + 4, true);
                    const nz = reader.getFloat32(start + 8, true);
                    
                    for (let i = 1; i <= 3; i++) {
                        const vStart = start + i * 12;
                        const idx = (face * 9) + ((i-1) * 3);
                        
                        vertices[idx] = reader.getFloat32(vStart, true);
                        vertices[idx + 1] = reader.getFloat32(vStart + 4, true);
                        vertices[idx + 2] = reader.getFloat32(vStart + 8, true);
                        
                        normals[idx] = nx;
                        normals[idx + 1] = ny;
                        normals[idx + 2] = nz;
                    }
                }
                
                const geo = new THREE.BufferGeometry();
                geo.setAttribute('position', new THREE.BufferAttribute(vertices, 3));
                geo.setAttribute('normal', new THREE.BufferAttribute(normals, 3));
                return geo;
            }
            
            function parseASCII(text) {
                log('ASCII STL format');
                const lines = text.split('\n');
                const vertices = [];
                const normals = [];
                let currentNormal = [0, 0, 1];
                
                for (const line of lines) {
                    const parts = line.trim().split(/\s+/);
                    if (parts[0] === 'facet' && parts[1] === 'normal') {
                        currentNormal = [parseFloat(parts[2]), parseFloat(parts[3]), parseFloat(parts[4])];
                    } else if (parts[0] === 'vertex') {
                        vertices.push(parseFloat(parts[1]), parseFloat(parts[2]), parseFloat(parts[3]));
                        normals.push(...currentNormal);
                    }
                }
                
                log(`ASCII STL: ${vertices.length/9} faces`);
                
                const geo = new THREE.BufferGeometry();
                geo.setAttribute('position', new THREE.Float32BufferAttribute(vertices, 3));
                geo.setAttribute('normal', new THREE.Float32BufferAttribute(normals, 3));
                return geo;
            }
            
            if (isBinary(buffer)) {
                return parseBinary(buffer);
            } else {
                const text = new TextDecoder().decode(buffer);
                return parseASCII(text);
            }
        }
        
        // ============ OBJ LOADER ============
        function parseOBJ(text) {
            log('Parsing OBJ...');
            
            const lines = text.split('\n');
            const vertices = [];   // v x y z
            const normals = [];    // vn x y z
            const uvs = [];        // vt u v
            
            const outPositions = [];
            const outNormals = [];
            
            let faceCount = 0;
            
            // First pass: collect all vertices, normals, uvs
            for (const line of lines) {
                const parts = line.trim().split(/\s+/);
                const cmd = parts[0];
                
                if (cmd === 'v') {
                    vertices.push([
                        parseFloat(parts[1]) || 0,
                        parseFloat(parts[2]) || 0,
                        parseFloat(parts[3]) || 0
                    ]);
                } else if (cmd === 'vn') {
                    normals.push([
                        parseFloat(parts[1]) || 0,
                        parseFloat(parts[2]) || 0,
                        parseFloat(parts[3]) || 0
                    ]);
                } else if (cmd === 'vt') {
                    uvs.push([
                        parseFloat(parts[1]) || 0,
                        parseFloat(parts[2]) || 0
                    ]);
                }
            }
            
            log(`OBJ: ${vertices.length} verts, ${normals.length} normals`);
            
            // Helper: parse face index (handles 1-based, negative, v/vt/vn formats)
            function parseFaceVertex(str) {
                const parts = str.split('/');
                let vi = parseInt(parts[0]) || 0;
                let ti = parseInt(parts[1]) || 0;  // texture index (unused)
                let ni = parseInt(parts[2]) || 0;  // normal index
                
                // Handle negative indices (relative to end)
                if (vi < 0) vi = vertices.length + vi + 1;
                if (ni < 0) ni = normals.length + ni + 1;
                
                // Convert to 0-based
                return { v: vi - 1, n: ni - 1 };
            }
            
            // Helper: add a triangle to output
            function addTriangle(a, b, c) {
                const va = vertices[a.v] || [0,0,0];
                const vb = vertices[b.v] || [0,0,0];
                const vc = vertices[c.v] || [0,0,0];
                
                outPositions.push(...va, ...vb, ...vc);
                
                // Use provided normals or compute face normal
                if (a.n >= 0 && normals[a.n] && b.n >= 0 && normals[b.n] && c.n >= 0 && normals[c.n]) {
                    outNormals.push(...normals[a.n], ...normals[b.n], ...normals[c.n]);
                } else {
                    // Compute face normal
                    const u = [vb[0]-va[0], vb[1]-va[1], vb[2]-va[2]];
                    const v = [vc[0]-va[0], vc[1]-va[1], vc[2]-va[2]];
                    const n = [
                        u[1]*v[2] - u[2]*v[1],
                        u[2]*v[0] - u[0]*v[2],
                        u[0]*v[1] - u[1]*v[0]
                    ];
                    const len = Math.sqrt(n[0]*n[0] + n[1]*n[1] + n[2]*n[2]) || 1;
                    n[0] /= len; n[1] /= len; n[2] /= len;
                    outNormals.push(...n, ...n, ...n);
                }
                
                faceCount++;
            }
            
            // Second pass: process faces
            for (const line of lines) {
                const parts = line.trim().split(/\s+/);
                if (parts[0] !== 'f') continue;
                
                // Parse all face vertices
                const faceVerts = [];
                for (let i = 1; i < parts.length; i++) {
                    if (parts[i].length > 0) {
                        faceVerts.push(parseFaceVertex(parts[i]));
                    }
                }
                
                if (faceVerts.length < 3) continue;
                
                // Triangulate using fan method
                // Works well for convex polygons (tris, quads, most n-gons)
                for (let i = 1; i < faceVerts.length - 1; i++) {
                    addTriangle(faceVerts[0], faceVerts[i], faceVerts[i + 1]);
                }
            }
            
            log(`OBJ: ${faceCount} triangles`);
            
            const geo = new THREE.BufferGeometry();
            geo.setAttribute('position', new THREE.Float32BufferAttribute(outPositions, 3));
            geo.setAttribute('normal', new THREE.Float32BufferAttribute(outNormals, 3));
            
            return geo;
        }
        
        // ============ HAND CONTROLLER ============
        class HandController {
            constructor(app) {
                this.app = app;
                this.hands = null;
                this.ready = false;
                this.active = false;
                
                // State machine
                this.state = 'IDLE'; // IDLE, TRACKING, FIST, PINCH, PALM
                this.prevState = 'IDLE';
                this.stateStartTime = 0;
                
                // Gesture detection with hysteresis
                this.gestureBuffer = [];
                this.gestureBufferSize = 5; // Frames to average
                this.gestureHoldTime = 150; // ms to confirm gesture change
                this.pendingGesture = null;
                this.pendingGestureStart = 0;
                
                // Tracking data
                this.landmarks = null;
                this.handCenter = { x: 0.5, y: 0.5 };
                this.prevHandCenter = { x: 0.5, y: 0.5 };
                this.pinchDistance = 0;
                this.prevPinchDistance = 0;
                this.palmHoldStart = 0;
                
                // Smoothing
                this.smoothRotX = 0;
                this.smoothRotY = 0;
                this.smoothScale = 1;
                
                // UI elements
                this.statusEl = $('gestureStatus');
                this.statusIcon = this.statusEl.querySelector('.icon');
                this.statusText = this.statusEl.querySelector('.text');
                this.progressEl = this.statusEl.querySelector('.progress');
                
                // Idle hint timer
                this.idleTimer = null;
                this.hintShown = false;
            }
            
            async init() {
                if (typeof Hands === 'undefined') {
                    log('MediaPipe Hands not available', 'e');
                    return false;
                }
                
                try {
                    log('Initializing hand tracking...');
                    this.hands = new Hands({
                        locateFile: f => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${f}`
                    });
                    
                    this.hands.setOptions({
                        maxNumHands: 1,
                        modelComplexity: 0, // 0 = lite, fastest
                        minDetectionConfidence: 0.6,
                        minTrackingConfidence: 0.5
                    });
                    
                    this.hands.onResults(r => this.onResults(r));
                    
                    this.ready = true;
                    log('Hand tracking ready', 'ok');
                    return true;
                } catch (err) {
                    log(`Hand init failed: ${err.message}`, 'e');
                    return false;
                }
            }
            
            start() {
                if (!this.ready) return;
                this.active = true;
                this.state = 'IDLE';
                this.showStatus('üëã', 'Show hand');
                this.statusEl.classList.add('show');
                $('helpBtn').classList.add('show');
                
                // Start idle hint timer
                this.startIdleTimer();
                
                log('Hand control started');
                this.runDetection();
            }
            
            stop() {
                this.active = false;
                this.state = 'IDLE';
                this.statusEl.classList.remove('show');
                this.statusEl.className = 'show'; // Reset classes
                $('helpBtn').classList.remove('show');
                this.clearIdleTimer();
                log('Hand control stopped');
            }
            
            startIdleTimer() {
                this.clearIdleTimer();
                this.idleTimer = setTimeout(() => {
                    if (this.active && this.state === 'IDLE' && !this.hintShown) {
                        this.hintShown = true;
                        $('gestureHelp').classList.add('show');
                    }
                }, 4000);
            }
            
            clearIdleTimer() {
                if (this.idleTimer) {
                    clearTimeout(this.idleTimer);
                    this.idleTimer = null;
                }
            }
            
            runDetection() {
                if (!this.active || !this.hands || !this.app.vid) return;
                
                const detect = async () => {
                    if (!this.active) return;
                    
                    if (this.app.vid.readyState >= 2) {
                        try {
                            await this.hands.send({ image: this.app.vid });
                        } catch (e) {
                            // Silently ignore send errors
                        }
                    }
                    
                    if (this.active) {
                        requestAnimationFrame(detect);
                    }
                };
                
                detect();
            }
            
            onResults(results) {
                if (!this.active) return;
                
                // Clear PIP overlay
                const ctx = this.app.ctx;
                const ovr = this.app.ovr;
                if (ctx) ctx.clearRect(0, 0, ovr.width, ovr.height);
                
                // Check for hand
                if (!results.multiHandLandmarks || results.multiHandLandmarks.length === 0) {
                    this.handleNoHand();
                    return;
                }
                
                // Store landmarks
                this.landmarks = results.multiHandLandmarks[0];
                
                // Draw hand skeleton
                this.drawHand(ctx, ovr);
                
                // Detect gesture
                const gesture = this.detectGesture();
                
                // Apply hysteresis
                this.processGestureWithHysteresis(gesture);
            }
            
            handleNoHand() {
                this.landmarks = null;
                
                // Only go to IDLE if we've been without a hand for a bit
                if (this.state !== 'IDLE') {
                    this.gestureBuffer.push('NONE');
                    if (this.gestureBuffer.length > this.gestureBufferSize) {
                        this.gestureBuffer.shift();
                    }
                    
                    const noneCount = this.gestureBuffer.filter(g => g === 'NONE').length;
                    if (noneCount >= this.gestureBufferSize - 1) {
                        this.setState('IDLE');
                        this.showStatus('üëã', 'Show hand');
                    }
                }
            }
            
            detectGesture() {
                if (!this.landmarks) return 'NONE';
                
                const lm = this.landmarks;
                
                // Key landmarks (MediaPipe hand indices)
                const WRIST = 0;
                const THUMB_TIP = 4;
                const INDEX_TIP = 8;
                const INDEX_MCP = 5;
                const MIDDLE_TIP = 12;
                const MIDDLE_MCP = 9;
                const RING_TIP = 16;
                const RING_MCP = 13;
                const PINKY_TIP = 20;
                const PINKY_MCP = 17;
                
                // Helper: distance between two landmarks
                const dist = (a, b) => {
                    const dx = lm[a].x - lm[b].x;
                    const dy = lm[a].y - lm[b].y;
                    return Math.sqrt(dx*dx + dy*dy);
                };
                
                // Helper: check if finger is curled
                const isCurled = (tip, mcp) => {
                    // Finger is curled if tip is below (higher y) than MCP
                    // and close horizontally
                    const tipY = lm[tip].y;
                    const mcpY = lm[mcp].y;
                    const wristY = lm[WRIST].y;
                    
                    // Normalized: is tip closer to wrist than MCP is?
                    return tipY > mcpY - 0.05;
                };
                
                // Calculate hand center (average of palm landmarks)
                const palmIndices = [0, 5, 9, 13, 17];
                let cx = 0, cy = 0;
                palmIndices.forEach(i => { cx += lm[i].x; cy += lm[i].y; });
                this.prevHandCenter = { ...this.handCenter };
                this.handCenter = { x: cx / 5, y: cy / 5 };
                
                // Calculate pinch distance
                this.prevPinchDistance = this.pinchDistance;
                this.pinchDistance = dist(THUMB_TIP, INDEX_TIP);
                
                // ===== GESTURE DETECTION =====
                
                // 1. PINCH: Thumb and index very close
                const pinchThreshold = 0.08;
                if (this.pinchDistance < pinchThreshold) {
                    return 'PINCH';
                }
                
                // 2. FIST: All fingers curled
                const fingersCurled = [
                    isCurled(INDEX_TIP, INDEX_MCP),
                    isCurled(MIDDLE_TIP, MIDDLE_MCP),
                    isCurled(RING_TIP, RING_MCP),
                    isCurled(PINKY_TIP, PINKY_MCP)
                ];
                const curledCount = fingersCurled.filter(Boolean).length;
                
                if (curledCount >= 3 && this.pinchDistance < 0.15) {
                    return 'FIST';
                }
                
                // 3. PALM: All fingers extended
                const fingersExtended = fingersCurled.map(c => !c);
                const extendedCount = fingersExtended.filter(Boolean).length;
                
                // Also check thumb is away from palm
                const thumbAway = dist(THUMB_TIP, INDEX_MCP) > 0.1;
                
                if (extendedCount >= 3 && thumbAway) {
                    return 'PALM';
                }
                
                // Default: just tracking, no specific gesture
                return 'TRACKING';
            }
            
            processGestureWithHysteresis(gesture) {
                const now = Date.now();
                
                // Add to buffer
                this.gestureBuffer.push(gesture);
                if (this.gestureBuffer.length > this.gestureBufferSize) {
                    this.gestureBuffer.shift();
                }
                
                // Find most common gesture in buffer
                const counts = {};
                this.gestureBuffer.forEach(g => { counts[g] = (counts[g] || 0) + 1; });
                
                let dominantGesture = 'TRACKING';
                let maxCount = 0;
                for (const g in counts) {
                    if (counts[g] > maxCount) {
                        maxCount = counts[g];
                        dominantGesture = g;
                    }
                }
                
                // Hysteresis: require gesture to be stable before switching
                if (dominantGesture !== this.pendingGesture) {
                    this.pendingGesture = dominantGesture;
                    this.pendingGestureStart = now;
                } else if (now - this.pendingGestureStart > this.gestureHoldTime) {
                    // Gesture held long enough, apply it
                    if (dominantGesture !== this.state && dominantGesture !== 'NONE') {
                        this.setState(dominantGesture);
                    }
                }
                
                // Apply gesture actions (continuous)
                this.applyGestureAction();
            }
            
            setState(newState) {
                if (newState === this.state) return;
                
                this.prevState = this.state;
                this.state = newState;
                this.stateStartTime = Date.now();
                
                log(`Gesture: ${newState}`);
                
                // Update UI
                this.statusEl.classList.remove('fist', 'pinch', 'palm');
                
                switch (newState) {
                    case 'IDLE':
                        this.showStatus('üëã', 'Show hand');
                        this.startIdleTimer();
                        break;
                    case 'TRACKING':
                        this.showStatus('‚úã', 'Tracking...');
                        this.clearIdleTimer();
                        break;
                    case 'FIST':
                        this.showStatus('‚úä', 'Rotate');
                        this.statusEl.classList.add('fist');
                        this.clearIdleTimer();
                        break;
                    case 'PINCH':
                        this.showStatus('ü§è', 'Scale');
                        this.statusEl.classList.add('pinch');
                        this.clearIdleTimer();
                        // Store initial scale
                        this.smoothScale = 1;
                        break;
                    case 'PALM':
                        this.palmHoldStart = Date.now();
                        this.showStatus('‚úã', 'Hold to reset');
                        this.statusEl.classList.add('palm');
                        this.clearIdleTimer();
                        break;
                }
            }
            
            applyGestureAction() {
                if (!this.landmarks) return;
                
                switch (this.state) {
                    case 'FIST':
                        this.applyRotation();
                        break;
                    case 'PINCH':
                        this.applyScale();
                        break;
                    case 'PALM':
                        this.checkPalmReset();
                        break;
                }
            }
            
            applyRotation() {
                // Calculate hand movement delta
                const dx = this.handCenter.x - this.prevHandCenter.x;
                const dy = this.handCenter.y - this.prevHandCenter.y;
                
                // Ignore tiny movements (noise)
                if (Math.abs(dx) < 0.002 && Math.abs(dy) < 0.002) return;
                
                // Apply rotation (inverted X because camera is mirrored)
                const sensitivity = 3;
                this.app.modelRotation.y += dx * sensitivity;
                this.app.modelRotation.x += dy * sensitivity;
            }
            
            applyScale() {
                // Calculate pinch delta
                const delta = this.pinchDistance - this.prevPinchDistance;
                
                // Ignore tiny changes
                if (Math.abs(delta) < 0.003) return;
                
                // Apply scale
                const sensitivity = 8;
                const scaleDelta = delta * sensitivity;
                
                // Update model scale with limits
                if (this.app.obj) {
                    const currentScale = this.app.obj.scale.x;
                    const newScale = Math.max(0.3, Math.min(3, currentScale + scaleDelta));
                    this.app.obj.scale.setScalar(newScale);
                    
                    // Update status text with percentage
                    const pct = Math.round(newScale * 100);
                    this.showStatus('ü§è', `Scale ${pct}%`);
                }
            }
            
            checkPalmReset() {
                const holdDuration = 2000; // 2 seconds
                const elapsed = Date.now() - this.palmHoldStart;
                const progress = Math.min(100, (elapsed / holdDuration) * 100);
                
                // Update progress bar
                this.progressEl.style.setProperty('--progress', `${progress}%`);
                
                if (elapsed >= holdDuration) {
                    // Reset!
                    this.app.resetRotation();
                    if (this.app.obj) {
                        this.app.obj.scale.setScalar(1);
                    }
                    this.showStatus('‚Ü∫', 'Reset!');
                    this.palmHoldStart = Date.now() + 1000; // Prevent immediate re-trigger
                    log('Transform reset via palm hold');
                    
                    // Brief feedback
                    setTimeout(() => {
                        if (this.state === 'PALM') {
                            this.showStatus('‚úã', 'Hold to reset');
                        }
                    }, 500);
                }
            }
            
            showStatus(icon, text) {
                this.statusIcon.textContent = icon;
                this.statusText.textContent = text;
            }
            
            drawHand(ctx, ovr) {
                if (!ctx || !this.landmarks) return;
                
                const lm = this.landmarks;
                const w = ovr.width;
                const h = ovr.height;
                
                ctx.save();
                ctx.translate(w, 0);
                ctx.scale(-1, 1); // Mirror
                
                // Draw connections
                const connections = [
                    [0,1],[1,2],[2,3],[3,4],       // Thumb
                    [0,5],[5,6],[6,7],[7,8],       // Index
                    [0,9],[9,10],[10,11],[11,12], // Middle
                    [0,13],[13,14],[14,15],[15,16], // Ring
                    [0,17],[17,18],[18,19],[19,20], // Pinky
                    [5,9],[9,13],[13,17]            // Palm
                ];
                
                ctx.strokeStyle = '#ff6600';
                ctx.lineWidth = 2;
                
                connections.forEach(([a, b]) => {
                    ctx.beginPath();
                    ctx.moveTo(lm[a].x * w, lm[a].y * h);
                    ctx.lineTo(lm[b].x * w, lm[b].y * h);
                    ctx.stroke();
                });
                
                // Draw landmarks
                ctx.fillStyle = '#fff';
                lm.forEach((point, i) => {
                    ctx.beginPath();
                    const size = [4, 8, 12, 16, 20].includes(i) ? 4 : 2; // Fingertips larger
                    ctx.arc(point.x * w, point.y * h, size, 0, Math.PI * 2);
                    ctx.fill();
                });
                
                ctx.restore();
            }
        }
        
        // ============ AUTO-ORIENTATION ============
        function autoOrientGeometry(geo) {
            geo.computeBoundingBox();
            const box = geo.boundingBox;
            const size = new THREE.Vector3();
            box.getSize(size);
            
            log(`Original dims: X=${size.x.toFixed(1)}, Y=${size.y.toFixed(1)}, Z=${size.z.toFixed(1)}`);
            
            // Analyze principal axes using vertex positions
            const pos = geo.attributes.position.array;
            let varX = 0, varY = 0, varZ = 0;
            const n = pos.length / 3;
            
            // Calculate variance in each axis
            let sumX = 0, sumY = 0, sumZ = 0;
            for (let i = 0; i < pos.length; i += 3) {
                sumX += pos[i];
                sumY += pos[i + 1];
                sumZ += pos[i + 2];
            }
            const meanX = sumX / n, meanY = sumY / n, meanZ = sumZ / n;
            
            for (let i = 0; i < pos.length; i += 3) {
                varX += (pos[i] - meanX) ** 2;
                varY += (pos[i + 1] - meanY) ** 2;
                varZ += (pos[i + 2] - meanZ) ** 2;
            }
            
            // Find which axis has lowest variance (likely the "flat" direction)
            const vars = [
                { axis: 'x', val: varX, size: size.x },
                { axis: 'y', val: varY, size: size.y },
                { axis: 'z', val: varZ, size: size.z }
            ];
            vars.sort((a, b) => a.size - b.size);
            
            const thinnest = vars[0].axis;
            const tallest = vars[2].axis;
            
            log(`Thinnest axis: ${thinnest}, Tallest axis: ${tallest}`);
            
            // Apply rotation to make model upright
            // We want the tallest dimension to be Y (up), thinnest to be Z (depth)
            let rotX = 0, rotZ = 0;
            
            if (tallest === 'z') {
                // Z is tallest, rotate to make it Y
                rotX = -Math.PI / 2;
                log('Auto-rotate: X -90¬∞ (Z‚ÜíY)');
            } else if (tallest === 'x') {
                // X is tallest, rotate to make it Y
                rotZ = Math.PI / 2;
                log('Auto-rotate: Z +90¬∞ (X‚ÜíY)');
            }
            
            // If after rotation the model is very flat in Z, it might be lying down
            if (thinnest === 'y' && tallest !== 'y') {
                rotX = -Math.PI / 2;
                log('Auto-rotate: X -90¬∞ (flat model)');
            }
            
            return { rotX, rotY: 0, rotZ };
        }
        
        // ============ MAIN APP ============
        class App {
            constructor() {
                log('App starting...');
                
                this.vid = $('vid');
                this.ovr = $('ovr');
                this.ctx = null;
                this.detector = null;
                
                this.scene = null;
                this.camera = null;
                this.renderer = null;
                this.obj = null;
                this.room = null;
                
                this.face = { x: 0, y: 0, z: 400 };
                this.smooth = { x: 0, y: 0, z: 400 };
                this.tracking = false;
                this.faceCount = 0;
                
                // Mode system
                this.mode = 'view'; // 'view' or 'edit'
                this.modelRotation = { x: 0, y: 0, z: 0 };
                this.baseRotation = { x: 0, y: 0, z: 0 }; // Store initial rotation
                
                // Touch rotation
                this.touchStart = null;
                this.lastTouchDist = 0;
                
                // Hand controller
                this.handController = null;
                
                this.init();
            }
            
            async init() {
                try {
                    log('Init 3D...');
                    this.setup3D();
                    stat('sModel', 'sneaker', 'ok');
                    
                    log('Init camera...');
                    await this.setupCamera();
                    
                    log('Init tracking...');
                    await this.setupTracking();
                    
                    log('Init UI...');
                    this.setupUI();
                    
                    log('Init touch rotation...');
                    this.setupTouchRotation();
                    
                    log('Init hand controller...');
                    this.handController = new HandController(this);
                    await this.handController.init();
                    
                    log('Starting render...');
                    this.animate();
                    
                    log('Ready!', 'ok');
                } catch (err) {
                    log(`Error: ${err.message}`, 'e');
                }
            }
            
            setup3D() {
                const canvas = $('canvas3d');
                this.scene = new THREE.Scene();
                this.camera = new THREE.PerspectiveCamera(60, innerWidth/innerHeight, 1, 5000);
                this.camera.position.z = 400;
                
                this.renderer = new THREE.WebGLRenderer({ canvas, antialias: true });
                this.renderer.setSize(innerWidth, innerHeight);
                this.renderer.setPixelRatio(Math.min(devicePixelRatio, 2));
                this.renderer.setClearColor(0x050508);
                
                // Lights
                this.scene.add(new THREE.AmbientLight(0xffffff, 0.4));
                const main = new THREE.DirectionalLight(0xffffff, 1);
                main.position.set(50, 100, 100);
                this.scene.add(main);
                const back = new THREE.DirectionalLight(0xff6600, 0.5);
                back.position.set(-50, -50, -100);
                this.scene.add(back);
                const blue = new THREE.PointLight(0x0066ff, 0.4, 500);
                blue.position.set(0, 100, -150);
                this.scene.add(blue);
                
                this.createRoom();
                this.makeObj('sneaker');
            }
            
            createRoom() {
                this.room = new THREE.Group();
                const gc = 0xff6600, gd = 0x1a0800;
                const D = 400, W = 350, H = 250;
                
                const floor = new THREE.GridHelper(W*2, 24, gc, gd);
                floor.position.set(0, -H/2, -D/2);
                floor.material.transparent = true;
                floor.material.opacity = 0.7;
                this.room.add(floor);
                
                const back = new THREE.GridHelper(W*2, 24, gc, gd);
                back.rotation.x = Math.PI/2;
                back.position.z = -D;
                back.material.transparent = true;
                back.material.opacity = 0.6;
                this.room.add(back);
                
                const left = new THREE.GridHelper(D, 16, gc, gd);
                left.rotation.z = Math.PI/2;
                left.position.set(-W, 0, -D/2);
                left.material.transparent = true;
                left.material.opacity = 0.4;
                this.room.add(left);
                
                const right = new THREE.GridHelper(D, 16, gc, gd);
                right.rotation.z = Math.PI/2;
                right.position.set(W, 0, -D/2);
                right.material.transparent = true;
                right.material.opacity = 0.4;
                this.room.add(right);
                
                const ceil = new THREE.GridHelper(W*2, 24, gc, gd);
                ceil.position.set(0, H/2, -D/2);
                ceil.material.transparent = true;
                ceil.material.opacity = 0.15;
                this.room.add(ceil);
                
                const lm = new THREE.LineBasicMaterial({color: gc, transparent: true, opacity: 0.5});
                [[-W,-H/2],[W,-H/2],[-W,H/2],[W,H/2]].forEach(([x,y]) => {
                    const g = new THREE.BufferGeometry().setFromPoints([
                        new THREE.Vector3(x,y,0), new THREE.Vector3(x,y,-D)
                    ]);
                    this.room.add(new THREE.Line(g, lm));
                });
                
                const hg = new THREE.PlaneGeometry(W*3, 4);
                const hm = new THREE.MeshBasicMaterial({color: gc, transparent: true, opacity: 0.8});
                const hz = new THREE.Mesh(hg, hm);
                hz.position.set(0, -H/2+2, -D+1);
                this.room.add(hz);
                
                this.scene.add(this.room);
            }
            
            makeObj(type) {
                if (this.obj) this.scene.remove(this.obj);
                $('modelInfo').classList.remove('show');
                stat('sModel', type, 'ok');
                
                // Reset rotation for built-in objects
                this.modelRotation = { x: 0, y: 0, z: 0 };
                this.baseRotation = { x: 0, y: 0, z: 0 };
                
                const g = new THREE.Group();
                
                if (type === 'sneaker') {
                    const s = 1.4;
                    const sole = new THREE.Mesh(new THREE.BoxGeometry(130*s,12*s,50*s), new THREE.MeshPhysicalMaterial({color:0x0a0a0a,roughness:0.9}));
                    sole.position.y = -45*s; g.add(sole);
                    
                    const mid = new THREE.Mesh(new THREE.BoxGeometry(125*s,22*s,48*s), new THREE.MeshPhysicalMaterial({color:0xffffff,roughness:0.3}));
                    mid.position.y = -28*s; g.add(mid);
                    
                    const upper = new THREE.Mesh(new THREE.BoxGeometry(115*s,45*s,44*s), new THREE.MeshPhysicalMaterial({color:0x1a1a1a,roughness:0.7}));
                    upper.position.y = 5*s; g.add(upper);
                    
                    const toe = new THREE.Mesh(new THREE.SphereGeometry(28*s,20,20), new THREE.MeshPhysicalMaterial({color:0x252525}));
                    toe.position.set(50*s,0,0); toe.scale.set(1.3,0.65,1); g.add(toe);
                    
                    for (let i=0; i<3; i++) {
                        const st = new THREE.Mesh(new THREE.BoxGeometry(5*s,35*s,46*s), new THREE.MeshBasicMaterial({color:0xff6600}));
                        st.position.set((-15+i*25)*s,8*s,0); st.rotation.z=0.2; g.add(st);
                    }
                    
                    const heel = new THREE.Mesh(new THREE.BoxGeometry(16*s,35*s,22*s), new THREE.MeshPhysicalMaterial({color:0xffcc00}));
                    heel.position.set(-58*s,18*s,0); g.add(heel);
                    
                    this.baseRotation.y = -0.35;
                    g.position.set(0, 20, -80);
                    
                } else if (type === 'cube') {
                    const c = new THREE.Mesh(new THREE.BoxGeometry(100,100,100), new THREE.MeshPhysicalMaterial({color:0xff6600,metalness:0.4,clearcoat:0.8}));
                    g.add(c);
                    const w = new THREE.Mesh(new THREE.BoxGeometry(102,102,102), new THREE.MeshBasicMaterial({color:0xffffff,wireframe:true,transparent:true,opacity:0.3}));
                    g.add(w);
                    g.position.z = -80;
                    
                } else if (type === 'gem') {
                    const gm = new THREE.Mesh(new THREE.OctahedronGeometry(70,0), new THREE.MeshPhysicalMaterial({color:0xff00ff,clearcoat:1,transparent:true,opacity:0.9}));
                    g.add(gm);
                    [0x00ffff,0xff00ff,0xffff00].forEach((c,i) => {
                        const r = new THREE.Mesh(new THREE.TorusGeometry(90+i*25,2,8,64), new THREE.MeshBasicMaterial({color:c}));
                        r.rotation.x = Math.PI/2+i*0.4; r.rotation.y = i*0.5;
                        r.userData.spd = 0.01+i*0.005;
                        g.add(r);
                    });
                    g.position.z = -80;
                }
                
                this.obj = g;
                this.scene.add(this.obj);
                log(`Object: ${type}`);
            }
            
            loadModel(file) {
                const ext = file.name.split('.').pop().toLowerCase();
                log(`Loading ${ext.toUpperCase()}: ${file.name}`);
                $('loading').classList.add('show');
                $('loadTxt').textContent = `Loading ${file.name}...`;
                stat('sModel', 'loading...', 'w');
                
                const reader = new FileReader();
                
                reader.onload = (e) => {
                    try {
                        let geo;
                        
                        if (ext === 'obj') {
                            // OBJ is text-based
                            const text = typeof e.target.result === 'string' 
                                ? e.target.result 
                                : new TextDecoder().decode(e.target.result);
                            geo = parseOBJ(text);
                        } else {
                            // STL can be binary or ASCII
                            geo = parseSTL(e.target.result);
                        }
                        
                        // Auto-orient BEFORE centering
                        const autoRot = autoOrientGeometry(geo);
                        
                        // Apply auto-rotation to geometry
                        if (autoRot.rotX !== 0 || autoRot.rotZ !== 0) {
                            const matrix = new THREE.Matrix4();
                            const euler = new THREE.Euler(autoRot.rotX, autoRot.rotY, autoRot.rotZ);
                            matrix.makeRotationFromEuler(euler);
                            geo.applyMatrix4(matrix);
                        }
                        
                        // Now center geometry
                        geo.computeBoundingBox();
                        const box = geo.boundingBox;
                        const center = new THREE.Vector3();
                        box.getCenter(center);
                        geo.translate(-center.x, -center.y, -center.z);
                        
                        // Scale to fit
                        const size = new THREE.Vector3();
                        box.getSize(size);
                        const maxDim = Math.max(size.x, size.y, size.z);
                        const scale = 150 / maxDim;
                        geo.scale(scale, scale, scale);
                        
                        log(`Final dims: ${(size.x*scale).toFixed(0)}x${(size.y*scale).toFixed(0)}x${(size.z*scale).toFixed(0)}`);
                        
                        geo.computeVertexNormals();
                        
                        if (this.obj) this.scene.remove(this.obj);
                        
                        const mat = new THREE.MeshPhysicalMaterial({
                            color: 0xff6600,
                            metalness: 0.3,
                            roughness: 0.4,
                            clearcoat: 0.3,
                            side: THREE.DoubleSide
                        });
                        
                        const mesh = new THREE.Mesh(geo, mat);
                        const group = new THREE.Group();
                        group.add(mesh);
                        group.position.z = -80;
                        
                        // Reset rotation tracking for new model
                        this.modelRotation = { x: 0, y: 0, z: 0 };
                        this.baseRotation = { x: 0, y: 0, z: 0 };
                        
                        this.obj = group;
                        this.scene.add(this.obj);
                        
                        $('modelName').textContent = file.name;
                        $('modelInfo').classList.add('show');
                        document.querySelectorAll('.ob').forEach(b => b.classList.remove('on'));
                        
                        stat('sModel', file.name.slice(0,10), 'ok');
                        $('loading').classList.remove('show');
                        log(`Loaded: ${file.name}`, 'ok');
                        
                    } catch (err) {
                        $('loading').classList.remove('show');
                        stat('sModel', 'ERROR', 'err');
                        log(`Load Error: ${err.message}`, 'e');
                        alert(`Error loading ${ext.toUpperCase()}:\n` + err.message);
                    }
                };
                
                reader.onerror = () => {
                    $('loading').classList.remove('show');
                    stat('sModel', 'ERROR', 'err');
                    log('File read error', 'e');
                    alert('Error reading file');
                };
                
                // Read as appropriate type
                if (ext === 'obj') {
                    reader.readAsText(file);
                } else {
                    reader.readAsArrayBuffer(file);
                }
            }
            
            // ============ MODE SYSTEM ============
            setMode(mode) {
                this.mode = mode;
                const btn = $('modeToggle');
                const controls = $('rotControls');
                const pip = $('pip');
                const hint = $('editHint');
                
                if (mode === 'view') {
                    btn.classList.remove('edit');
                    btn.innerHTML = '<span class="icon">üëÅÔ∏è</span><span class="label">VIEW MODE</span>';
                    controls.classList.remove('show');
                    pip.classList.remove('paused');
                    stat('sMode', 'VIEW', 'ok');
                    log('Mode: VIEW (parallax on)');
                    
                    // Stop hand controller
                    if (this.handController) {
                        this.handController.stop();
                    }
                } else {
                    btn.classList.add('edit');
                    btn.innerHTML = '<span class="icon">‚úã</span><span class="label">EDIT MODE</span>';
                    controls.classList.add('show');
                    pip.classList.add('paused');
                    stat('sMode', 'EDIT', 'w');
                    log('Mode: EDIT (parallax paused)');
                    
                    // Start hand controller
                    if (this.handController && this.handController.ready) {
                        this.handController.start();
                    } else {
                        // Show hint for touch controls if no hand tracking
                        hint.classList.add('show');
                        setTimeout(() => hint.classList.remove('show'), 2000);
                    }
                }
            }
            
            toggleMode() {
                this.setMode(this.mode === 'view' ? 'edit' : 'view');
            }
            
            rotateModel(axis, angleDeg) {
                const angle = (angleDeg * Math.PI) / 180;
                this.modelRotation[axis] += angle;
                log(`Rotate ${axis.toUpperCase()}: ${angleDeg > 0 ? '+' : ''}${angleDeg}¬∞`);
            }
            
            resetRotation() {
                this.modelRotation = { x: 0, y: 0, z: 0 };
                log('Rotation reset');
            }
            
            // ============ TOUCH ROTATION ============
            setupTouchRotation() {
                const canvas = $('canvas3d');
                
                // Track touches
                canvas.addEventListener('touchstart', (e) => {
                    if (this.mode !== 'edit') return;
                    
                    if (e.touches.length === 2) {
                        e.preventDefault();
                        const t1 = e.touches[0];
                        const t2 = e.touches[1];
                        this.touchStart = {
                            x: (t1.clientX + t2.clientX) / 2,
                            y: (t1.clientY + t2.clientY) / 2,
                            rotX: this.modelRotation.x,
                            rotY: this.modelRotation.y
                        };
                        log('Touch rotate start');
                    }
                }, { passive: false });
                
                canvas.addEventListener('touchmove', (e) => {
                    if (this.mode !== 'edit' || !this.touchStart) return;
                    
                    if (e.touches.length === 2) {
                        e.preventDefault();
                        const t1 = e.touches[0];
                        const t2 = e.touches[1];
                        const cx = (t1.clientX + t2.clientX) / 2;
                        const cy = (t1.clientY + t2.clientY) / 2;
                        
                        const dx = cx - this.touchStart.x;
                        const dy = cy - this.touchStart.y;
                        
                        // Convert drag to rotation
                        const sensitivity = 0.01;
                        this.modelRotation.y = this.touchStart.rotY + dx * sensitivity;
                        this.modelRotation.x = this.touchStart.rotX + dy * sensitivity;
                    }
                }, { passive: false });
                
                canvas.addEventListener('touchend', () => {
                    if (this.touchStart) {
                        this.touchStart = null;
                        log('Touch rotate end');
                    }
                });
                
                // Mouse fallback for desktop
                let mouseDown = false;
                let mouseStart = null;
                
                canvas.addEventListener('mousedown', (e) => {
                    if (this.mode !== 'edit') return;
                    mouseDown = true;
                    mouseStart = {
                        x: e.clientX,
                        y: e.clientY,
                        rotX: this.modelRotation.x,
                        rotY: this.modelRotation.y
                    };
                });
                
                canvas.addEventListener('mousemove', (e) => {
                    if (!mouseDown || this.mode !== 'edit' || !mouseStart) return;
                    
                    const dx = e.clientX - mouseStart.x;
                    const dy = e.clientY - mouseStart.y;
                    
                    const sensitivity = 0.005;
                    this.modelRotation.y = mouseStart.rotY + dx * sensitivity;
                    this.modelRotation.x = mouseStart.rotX + dy * sensitivity;
                });
                
                canvas.addEventListener('mouseup', () => {
                    mouseDown = false;
                    mouseStart = null;
                });
                
                canvas.addEventListener('mouseleave', () => {
                    mouseDown = false;
                    mouseStart = null;
                });
            }
            
            async setupCamera() {
                stat('sCam', '...', '');
                try {
                    const stream = await navigator.mediaDevices.getUserMedia({
                        video: { facingMode: 'user', width: { ideal: 320 }, height: { ideal: 240 } },
                        audio: false
                    });
                    this.vid.srcObject = stream;
                    
                    await new Promise((res, rej) => {
                        this.vid.onloadedmetadata = () => {
                            this.ovr.width = this.vid.videoWidth;
                            this.ovr.height = this.vid.videoHeight;
                            this.ctx = this.ovr.getContext('2d');
                            this.vid.play().then(res).catch(rej);
                        };
                        setTimeout(() => rej(new Error('Timeout')), 8000);
                    });
                    
                    stat('sCam', 'OK', 'ok');
                    log(`Cam: ${this.vid.videoWidth}x${this.vid.videoHeight}`);
                } catch (err) {
                    stat('sCam', 'FAIL', 'err');
                    log(`Cam error: ${err.message}`, 'e');
                    this.setupTouch();
                }
            }
            
            setupTouch() {
                stat('sTrack', 'Touch', 'w');
                log('Using touch fallback', 'w');
                
                const upd = (x, y) => {
                    if (this.mode !== 'view') return; // Only track in view mode
                    this.face.x = -((x/innerWidth) - 0.5) * 400;
                    this.face.y = -((y/innerHeight) - 0.5) * 300;
                    this.tracking = true;
                    $('dot').classList.add('on');
                    stat('sFace', 'Touch', 'ok');
                };
                
                document.addEventListener('mousemove', e => upd(e.clientX, e.clientY));
                document.addEventListener('touchmove', e => {
                    if (e.touches.length === 1 && this.mode === 'view') {
                        upd(e.touches[0].clientX, e.touches[0].clientY);
                    }
                }, { passive: true });
            }
            
            async setupTracking() {
                if (!this.vid.srcObject) {
                    stat('sTrack', 'None', 'err');
                    return;
                }
                
                stat('sTrack', '...', '');
                
                if (typeof FaceDetection !== 'undefined') {
                    try {
                        log('Trying MediaPipe...');
                        this.detector = new FaceDetection({
                            locateFile: f => `https://cdn.jsdelivr.net/npm/@mediapipe/face_detection/${f}`
                        });
                        this.detector.setOptions({ model: 'short', minDetectionConfidence: 0.5 });
                        this.detector.onResults(r => this.onFace(r));
                        stat('sTrack', 'MediaPipe', 'ok');
                        log('MediaPipe ready');
                        this.runDetection();
                        return;
                    } catch (err) {
                        log(`MediaPipe failed: ${err.message}`, 'w');
                    }
                }
                
                if ('FaceDetector' in window) {
                    try {
                        log('Trying Native...');
                        this.nativeDetector = new window.FaceDetector({ fastMode: true, maxDetectedFaces: 1 });
                        stat('sTrack', 'Native', 'ok');
                        log('Native ready');
                        this.runNative();
                        return;
                    } catch (err) {
                        log(`Native failed: ${err.message}`, 'w');
                    }
                }
                
                stat('sTrack', 'Simple', 'w');
                log('Using simple tracking', 'w');
                this.runSimple();
            }
            
            runDetection() {
                const run = async () => {
                    if (this.detector && this.vid.readyState >= 2 && this.mode === 'view') {
                        try {
                            await this.detector.send({ image: this.vid });
                        } catch (e) {}
                    }
                    requestAnimationFrame(run);
                };
                run();
            }
            
            runNative() {
                const run = async () => {
                    if (this.nativeDetector && this.vid.readyState >= 2 && this.mode === 'view') {
                        try {
                            const faces = await this.nativeDetector.detect(this.vid);
                            this.processNative(faces);
                        } catch (e) {}
                    }
                    requestAnimationFrame(run);
                };
                run();
            }
            
            runSimple() {
                const tmp = document.createElement('canvas');
                tmp.width = 64; tmp.height = 48;
                const tc = tmp.getContext('2d');
                
                const run = () => {
                    if (this.vid.readyState >= 2 && this.mode === 'view') {
                        tc.drawImage(this.vid, 0, 0, 64, 48);
                        const d = tc.getImageData(0, 0, 64, 48).data;
                        
                        let maxB = 0, bx = 32, by = 24;
                        for (let y = 10; y < 38; y += 3) {
                            for (let x = 16; x < 48; x += 3) {
                                const i = (y * 64 + x) * 4;
                                const b = d[i] + d[i+1] + d[i+2];
                                if (b > maxB) { maxB = b; bx = x; by = y; }
                            }
                        }
                        
                        if (maxB > 250) {
                            this.face.x = -(((bx/64) - 0.5) * 2) * 250;
                            this.face.y = -(((by/48) - 0.5) * 2) * 180;
                            this.tracking = true;
                            $('dot').classList.add('on');
                            stat('sFace', 'YES', 'ok');
                            this.drawDot(bx/64, by/48);
                        } else {
                            this.tracking = false;
                            $('dot').classList.remove('on');
                            stat('sFace', 'NO', 'err');
                        }
                        stat('sX', this.face.x.toFixed(0));
                        stat('sY', this.face.y.toFixed(0));
                    }
                    requestAnimationFrame(run);
                };
                run();
            }
            
            onFace(results) {
                if (this.mode !== 'view') return;
                
                if (this.ctx) this.ctx.clearRect(0, 0, this.ovr.width, this.ovr.height);
                
                if (results.detections && results.detections.length > 0) {
                    this.faceCount++;
                    const b = results.detections[0].boundingBox;
                    
                    this.drawBox(b.xCenter, b.yCenter, b.width, b.height);
                    
                    this.face.x = -(b.xCenter - 0.5) * 2 * 250;
                    this.face.y = -(b.yCenter - 0.5) * 2 * 180;
                    
                    const fSize = Math.max(b.width, b.height);
                    this.face.z = Math.max(200, Math.min(700, 350 / Math.max(0.15, fSize)));
                    
                    this.tracking = true;
                    $('dot').classList.add('on');
                    stat('sFace', `#${this.faceCount}`, 'ok');
                } else {
                    this.tracking = false;
                    $('dot').classList.remove('on');
                    stat('sFace', 'NO', 'err');
                }
                stat('sX', this.face.x.toFixed(0));
                stat('sY', this.face.y.toFixed(0));
            }
            
            processNative(faces) {
                if (this.mode !== 'view') return;
                
                if (this.ctx) this.ctx.clearRect(0, 0, this.ovr.width, this.ovr.height);
                
                if (faces.length > 0) {
                    this.faceCount++;
                    const f = faces[0].boundingBox;
                    const cx = (f.x + f.width/2) / this.vid.videoWidth;
                    const cy = (f.y + f.height/2) / this.vid.videoHeight;
                    
                    this.drawBox(cx, cy, f.width/this.vid.videoWidth, f.height/this.vid.videoHeight);
                    
                    this.face.x = -(cx - 0.5) * 2 * 250;
                    this.face.y = -(cy - 0.5) * 2 * 180;
                    
                    this.tracking = true;
                    $('dot').classList.add('on');
                    stat('sFace', `#${this.faceCount}`, 'ok');
                } else {
                    this.tracking = false;
                    $('dot').classList.remove('on');
                    stat('sFace', 'NO', 'err');
                }
                stat('sX', this.face.x.toFixed(0));
                stat('sY', this.face.y.toFixed(0));
            }
            
            drawBox(cx, cy, w, h) {
                if (!this.ctx) return;
                const c = this.ctx, ow = this.ovr.width, oh = this.ovr.height;
                c.save();
                c.translate(ow, 0);
                c.scale(-1, 1);
                
                const x = cx * ow, y = cy * oh;
                c.strokeStyle = '#ff6600';
                c.lineWidth = 2;
                c.strokeRect(x - (w*ow)/2, y - (h*oh)/2, w*ow, h*oh);
                
                c.beginPath();
                c.arc(x, y, 5, 0, Math.PI*2);
                c.fillStyle = '#ff6600';
                c.fill();
                
                c.restore();
            }
            
            drawDot(nx, ny) {
                if (!this.ctx) return;
                const c = this.ctx;
                c.clearRect(0, 0, this.ovr.width, this.ovr.height);
                c.save();
                c.translate(this.ovr.width, 0);
                c.scale(-1, 1);
                c.beginPath();
                c.arc(nx * this.ovr.width, ny * this.ovr.height, 10, 0, Math.PI*2);
                c.strokeStyle = '#ff6600';
                c.lineWidth = 2;
                c.stroke();
                c.restore();
            }
            
            setupUI() {
                // Object buttons
                document.querySelectorAll('.ob').forEach(b => {
                    b.onclick = () => {
                        document.querySelectorAll('.ob').forEach(x => x.classList.remove('on'));
                        b.classList.add('on');
                        this.makeObj(b.dataset.o);
                    };
                });
                
                // Upload
                $('uploadBtn').onclick = () => {
                    log('Upload clicked');
                    $('fileInput').click();
                };
                
                $('fileInput').onchange = (e) => {
                    const file = e.target.files[0];
                    if (file) {
                        log(`File selected: ${file.name} (${(file.size/1024).toFixed(1)}KB)`);
                        this.loadModel(file);
                    }
                    e.target.value = '';
                };
                
                // Clear model
                $('clearModel').onclick = () => {
                    this.makeObj('sneaker');
                    document.querySelector('.ob[data-o="sneaker"]').classList.add('on');
                };
                
                // Mode toggle
                $('modeToggle').onclick = () => this.toggleMode();
                
                // Rotation buttons
                document.querySelectorAll('#rotControls button[data-axis]').forEach(btn => {
                    btn.onclick = () => {
                        const axis = btn.dataset.axis;
                        const dir = parseInt(btn.dataset.dir);
                        this.rotateModel(axis, dir * 90);
                    };
                });
                
                // Reset rotation
                $('resetRot').onclick = () => this.resetRotation();
                
                // Help button
                $('helpBtn').onclick = () => {
                    $('gestureHelp').classList.add('show');
                };
                
                // Close help
                $('closeHelp').onclick = () => {
                    $('gestureHelp').classList.remove('show');
                };
                
                // Resize
                window.addEventListener('resize', () => {
                    this.camera.aspect = innerWidth / innerHeight;
                    this.camera.updateProjectionMatrix();
                    this.renderer.setSize(innerWidth, innerHeight);
                });
                
                log('UI ready');
            }
            
            updateProjection() {
                // Only update face tracking in view mode
                if (this.mode === 'view') {
                    this.smooth.x += (this.face.x - this.smooth.x) * 0.1;
                    this.smooth.y += (this.face.y - this.smooth.y) * 0.1;
                    this.smooth.z += (this.face.z - this.smooth.z) * 0.1;
                }
                
                const { x, y, z } = this.smooth;
                const asp = innerWidth / innerHeight;
                const hw = 180, hh = hw / asp;
                const n = 10, f = 3000, r = n / z;
                
                this.camera.projectionMatrix.makePerspective(
                    (-hw - x) * r, (hw - x) * r,
                    (hh - y) * r, (-hh - y) * r,
                    n, f
                );
                this.camera.projectionMatrixInverse.copy(this.camera.projectionMatrix).invert();
                this.camera.position.set(x, y, z);
                this.camera.lookAt(x, y, -200);
            }
            
            animate() {
                requestAnimationFrame(() => this.animate());
                this.updateProjection();
                
                // Apply rotation to object
                if (this.obj) {
                    this.obj.rotation.x = this.baseRotation.x + this.modelRotation.x;
                    this.obj.rotation.y = this.baseRotation.y + this.modelRotation.y;
                    this.obj.rotation.z = this.baseRotation.z + this.modelRotation.z;
                    
                    // Animate gem rings
                    this.obj.children.forEach(c => {
                        if (c.userData && c.userData.spd) {
                            c.rotation.z += c.userData.spd;
                        }
                    });
                }
                
                this.renderer.render(this.scene, this.camera);
            }
        }
        
        // START
        log('Page loaded');
        new App();
    })();
    </script>
</body>
</html>
