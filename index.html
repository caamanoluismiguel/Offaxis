<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <title>OffAxis 3D</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            background: #08080c;
            overflow: hidden;
            font-family: -apple-system, sans-serif;
            touch-action: none;
        }
        #canvas3d {
            width: 100vw;
            height: 100vh;
            display: block;
        }
        
        /* PIP */
        #pip {
            position: fixed;
            bottom: 20px;
            right: 20px;
            width: 120px;
            height: 160px;
            border-radius: 12px;
            overflow: hidden;
            z-index: 100;
            background: #000;
            border: 2px solid #ff6600;
        }
        #pip video {
            width: 100%;
            height: 100%;
            object-fit: cover;
            transform: scaleX(-1);
        }
        #pip canvas {
            position: absolute;
            top: 0; left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
        }
        #trackDot {
            position: absolute;
            top: 8px; left: 8px;
            width: 10px; height: 10px;
            border-radius: 50%;
            background: #ff3b30;
            transition: all 0.3s;
        }
        #trackDot.on { background: #30d158; box-shadow: 0 0 10px #30d158; }
        
        /* Debug */
        #debug {
            position: fixed;
            top: 10px;
            left: 10px;
            right: 150px;
            max-height: 35vh;
            background: rgba(0,0,0,0.9);
            border: 1px solid #333;
            border-radius: 8px;
            padding: 10px;
            font-family: monospace;
            font-size: 10px;
            color: #0f0;
            overflow-y: auto;
            z-index: 1000;
        }
        #debug .e { color: #f55; }
        #debug .w { color: #fa0; }
        #debug .s { color: #0f0; }
        
        /* Status */
        #status {
            position: fixed;
            top: 10px;
            right: 10px;
            background: rgba(0,0,0,0.9);
            border: 1px solid #333;
            border-radius: 8px;
            padding: 10px;
            font-size: 10px;
            color: #fff;
            z-index: 100;
            min-width: 130px;
        }
        #status div { margin: 3px 0; display: flex; justify-content: space-between; }
        #status .v { color: #ff6600; font-family: monospace; }
        
        /* Objects */
        #objs {
            position: fixed;
            left: 16px;
            bottom: 20px;
            display: flex;
            gap: 8px;
            z-index: 100;
        }
        .ob {
            width: 44px; height: 44px;
            border-radius: 10px;
            border: none;
            background: rgba(255,255,255,0.1);
            color: #fff;
            font-size: 18px;
            cursor: pointer;
        }
        .ob.on { background: rgba(255,102,0,0.3); box-shadow: 0 0 0 2px #ff6600; }
    </style>
</head>
<body>
    <canvas id="canvas3d"></canvas>
    
    <div id="pip">
        <video id="vid" playsinline autoplay muted></video>
        <canvas id="ovr"></canvas>
        <div id="trackDot"></div>
    </div>
    
    <div id="debug"></div>
    
    <div id="status">
        <div>Camera <span class="v" id="sCam">--</span></div>
        <div>Video <span class="v" id="sVid">--</span></div>
        <div>Model <span class="v" id="sMod">--</span></div>
        <div>Faces <span class="v" id="sFace">--</span></div>
        <div>X <span class="v" id="sX">0</span></div>
        <div>Y <span class="v" id="sY">0</span></div>
    </div>
    
    <div id="objs">
        <button class="ob on" data-o="shoe">ðŸ‘Ÿ</button>
        <button class="ob" data-o="cube">ðŸŽ²</button>
        <button class="ob" data-o="gem">ðŸ’Ž</button>
    </div>

    <!-- THREE.JS -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    
    <!-- MediaPipe Face Detection - OFFICIAL GOOGLE CDN -->
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/face_detection/face_detection.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
    
    <script>
    (function() {
        'use strict';
        
        const $ = id => document.getElementById(id);
        const dbg = $('debug');
        let lc = 0;
        
        function log(m, t='s') {
            const d = document.createElement('div');
            d.className = t;
            d.textContent = `[${++lc}] ${m}`;
            dbg.appendChild(d);
            dbg.scrollTop = dbg.scrollHeight;
            console.log(`[${t}] ${m}`);
        }
        
        function stat(id, v, c) {
            const e = $(id);
            if (e) { e.textContent = v; if (c) e.style.color = c; }
        }
        
        // =====================
        // MAIN APP
        // =====================
        class App {
            constructor() {
                log('Starting app...');
                
                this.vid = $('vid');
                this.ovr = $('ovr');
                this.ctx = null;
                this.faceDetector = null;
                
                this.scene = null;
                this.camera = null;
                this.renderer = null;
                this.obj = null;
                this.grid = null;
                
                this.face = { x: 0, y: 0, z: 500 };
                this.smooth = { x: 0, y: 0, z: 500 };
                this.tracking = false;
                
                this.init();
            }
            
            async init() {
                try {
                    log('Setting up 3D...');
                    this.setup3D();
                    log('3D ready âœ“', 's');
                    
                    log('Setting up camera...');
                    await this.setupCamera();
                    
                    log('Setting up face detection...');
                    await this.setupFaceDetection();
                    
                    this.setupUI();
                    this.animate();
                    
                    log('=== ALL READY ===', 's');
                } catch (err) {
                    log(`ERROR: ${err.message}`, 'e');
                }
            }
            
            setup3D() {
                const canvas = $('canvas3d');
                this.scene = new THREE.Scene();
                this.camera = new THREE.PerspectiveCamera(50, innerWidth/innerHeight, 1, 5000);
                this.camera.position.z = 500;
                
                this.renderer = new THREE.WebGLRenderer({ canvas, antialias: true });
                this.renderer.setSize(innerWidth, innerHeight);
                this.renderer.setPixelRatio(Math.min(devicePixelRatio, 2));
                this.renderer.setClearColor(0x08080c);
                
                this.scene.add(new THREE.AmbientLight(0xffffff, 0.4));
                const light = new THREE.DirectionalLight(0xffffff, 1);
                light.position.set(100, 150, 100);
                this.scene.add(light);
                
                this.grid = new THREE.GridHelper(400, 20, 0xff6600, 0x1a0800);
                this.grid.position.y = -80;
                this.scene.add(this.grid);
                
                this.makeObj('shoe');
            }
            
            makeObj(type) {
                if (this.obj) this.scene.remove(this.obj);
                const g = new THREE.Group();
                
                if (type === 'shoe') {
                    g.add(new THREE.Mesh(new THREE.BoxGeometry(100,14,40), new THREE.MeshPhysicalMaterial({color:0x1a1a1a})));
                    g.children[0].position.y = -30;
                    const mid = new THREE.Mesh(new THREE.BoxGeometry(95,18,38), new THREE.MeshPhysicalMaterial({color:0xffffff}));
                    mid.position.y = -16; g.add(mid);
                    const up = new THREE.Mesh(new THREE.BoxGeometry(85,35,34), new THREE.MeshPhysicalMaterial({color:0x2d2d2d}));
                    up.position.y = 8; g.add(up);
                    for (let i=0; i<3; i++) {
                        const s = new THREE.Mesh(new THREE.BoxGeometry(4,26,36), new THREE.MeshBasicMaterial({color:0xff6600}));
                        s.position.set(-10+i*18, 8, 0); s.rotation.z = 0.25; g.add(s);
                    }
                    g.rotation.y = -0.4; g.position.y = 10;
                } else if (type === 'cube') {
                    g.add(new THREE.Mesh(new THREE.BoxGeometry(80,80,80), new THREE.MeshPhysicalMaterial({color:0xff6600,metalness:0.3})));
                } else if (type === 'gem') {
                    g.add(new THREE.Mesh(new THREE.OctahedronGeometry(50,0), new THREE.MeshPhysicalMaterial({color:0xff00ff,clearcoat:1})));
                }
                
                this.obj = g;
                this.scene.add(this.obj);
            }
            
            async setupCamera() {
                stat('sCam', '...', '#fa0');
                
                try {
                    const stream = await navigator.mediaDevices.getUserMedia({
                        video: { facingMode: 'user', width: { ideal: 320 }, height: { ideal: 240 } },
                        audio: false
                    });
                    
                    this.vid.srcObject = stream;
                    
                    await new Promise((res, rej) => {
                        this.vid.onloadedmetadata = () => {
                            this.ovr.width = this.vid.videoWidth;
                            this.ovr.height = this.vid.videoHeight;
                            this.ctx = this.ovr.getContext('2d');
                            this.vid.play().then(res).catch(rej);
                        };
                        setTimeout(() => rej(new Error('Timeout')), 10000);
                    });
                    
                    stat('sCam', 'OK', '#0f0');
                    stat('sVid', `${this.vid.videoWidth}x${this.vid.videoHeight}`, '#0f0');
                    log(`Camera: ${this.vid.videoWidth}x${this.vid.videoHeight} âœ“`, 's');
                    
                } catch (err) {
                    log(`Camera error: ${err.message}`, 'e');
                    stat('sCam', 'FAIL', '#f55');
                    this.setupTouch();
                }
            }
            
            setupTouch() {
                log('Using touch fallback', 'w');
                const upd = (x, y) => {
                    this.face.x = -((x/innerWidth) - 0.5) * 300;
                    this.face.y = -((y/innerHeight) - 0.5) * 200;
                    this.tracking = true;
                    $('trackDot').classList.add('on');
                };
                document.addEventListener('mousemove', e => upd(e.clientX, e.clientY));
                document.addEventListener('touchmove', e => { e.preventDefault(); upd(e.touches[0].clientX, e.touches[0].clientY); }, {passive:false});
            }
            
            async setupFaceDetection() {
                if (!this.vid.srcObject) {
                    log('No camera - skip face detection', 'w');
                    return;
                }
                
                stat('sMod', '...', '#fa0');
                
                // Check if MediaPipe loaded
                if (typeof FaceDetection === 'undefined') {
                    log('MediaPipe not loaded, trying alternative...', 'w');
                    await this.setupFaceDetectionAlt();
                    return;
                }
                
                try {
                    log('Creating MediaPipe FaceDetection...');
                    
                    this.faceDetector = new FaceDetection({
                        locateFile: (file) => {
                            return `https://cdn.jsdelivr.net/npm/@mediapipe/face_detection/${file}`;
                        }
                    });
                    
                    this.faceDetector.setOptions({
                        model: 'short',
                        minDetectionConfidence: 0.5
                    });
                    
                    this.faceDetector.onResults((results) => {
                        this.onFaceResults(results);
                    });
                    
                    log('MediaPipe configured âœ“', 's');
                    stat('sMod', 'MP', '#0f0');
                    
                    // Start detection loop
                    this.detectLoop();
                    
                } catch (err) {
                    log(`MediaPipe error: ${err.message}`, 'e');
                    log('Trying alternative method...', 'w');
                    await this.setupFaceDetectionAlt();
                }
            }
            
            async setupFaceDetectionAlt() {
                // Try native FaceDetector API (Chrome 94+)
                if ('FaceDetector' in window) {
                    try {
                        log('Trying native FaceDetector API...', 'w');
                        this.nativeFaceDetector = new window.FaceDetector({
                            fastMode: true,
                            maxDetectedFaces: 1
                        });
                        stat('sMod', 'Native', '#0f0');
                        log('Native FaceDetector ready âœ“', 's');
                        this.detectLoopNative();
                        return;
                    } catch (e) {
                        log(`Native API failed: ${e.message}`, 'e');
                    }
                }
                
                // Final fallback - simple motion-based tracking
                log('Using simple tracking fallback', 'w');
                stat('sMod', 'Simple', '#fa0');
                this.detectLoopSimple();
            }
            
            detectLoop() {
                const detect = async () => {
                    if (!this.faceDetector || this.vid.readyState < 2) {
                        requestAnimationFrame(detect);
                        return;
                    }
                    
                    try {
                        await this.faceDetector.send({ image: this.vid });
                    } catch (e) {
                        // Silently continue
                    }
                    
                    requestAnimationFrame(detect);
                };
                detect();
            }
            
            async detectLoopNative() {
                const detect = async () => {
                    if (!this.nativeFaceDetector || this.vid.readyState < 2) {
                        requestAnimationFrame(detect);
                        return;
                    }
                    
                    try {
                        const faces = await this.nativeFaceDetector.detect(this.vid);
                        this.processNativeFaces(faces);
                    } catch (e) {
                        // Silently continue
                    }
                    
                    requestAnimationFrame(detect);
                };
                detect();
            }
            
            detectLoopSimple() {
                // Canvas-based brightness tracking as ultimate fallback
                let prevBrightness = null;
                const tempCanvas = document.createElement('canvas');
                tempCanvas.width = 64;
                tempCanvas.height = 48;
                const tempCtx = tempCanvas.getContext('2d');
                
                const detect = () => {
                    if (this.vid.readyState < 2) {
                        requestAnimationFrame(detect);
                        return;
                    }
                    
                    // Sample video into small canvas
                    tempCtx.drawImage(this.vid, 0, 0, 64, 48);
                    const data = tempCtx.getImageData(0, 0, 64, 48).data;
                    
                    // Find brightest region (likely face)
                    let maxBright = 0;
                    let brightX = 32, brightY = 24;
                    
                    for (let y = 8; y < 40; y += 4) {
                        for (let x = 8; x < 56; x += 4) {
                            const i = (y * 64 + x) * 4;
                            const bright = data[i] + data[i+1] + data[i+2];
                            if (bright > maxBright) {
                                maxBright = bright;
                                brightX = x;
                                brightY = y;
                            }
                        }
                    }
                    
                    if (maxBright > 200) {
                        // Normalize to -1 to 1, flip X for mirror
                        const nx = -((brightX / 64) - 0.5) * 2;
                        const ny = ((brightY / 48) - 0.5) * 2;
                        
                        this.face.x = nx * 150;
                        this.face.y = -ny * 100;
                        
                        this.tracking = true;
                        $('trackDot').classList.add('on');
                        stat('sFace', 'YES', '#0f0');
                        
                        // Draw indicator
                        if (this.ctx) {
                            this.ctx.clearRect(0, 0, this.ovr.width, this.ovr.height);
                            this.ctx.save();
                            this.ctx.translate(this.ovr.width, 0);
                            this.ctx.scale(-1, 1);
                            
                            const dx = (brightX / 64) * this.ovr.width;
                            const dy = (brightY / 48) * this.ovr.height;
                            
                            this.ctx.beginPath();
                            this.ctx.arc(dx, dy, 15, 0, Math.PI * 2);
                            this.ctx.strokeStyle = '#ff6600';
                            this.ctx.lineWidth = 3;
                            this.ctx.stroke();
                            this.ctx.restore();
                        }
                    } else {
                        this.tracking = false;
                        $('trackDot').classList.remove('on');
                        stat('sFace', 'NO', '#f55');
                    }
                    
                    stat('sX', this.face.x.toFixed(0));
                    stat('sY', this.face.y.toFixed(0));
                    
                    requestAnimationFrame(detect);
                };
                
                detect();
                log('Simple tracking started âœ“', 's');
            }
            
            onFaceResults(results) {
                if (this.ctx) {
                    this.ctx.clearRect(0, 0, this.ovr.width, this.ovr.height);
                }
                
                if (results.detections && results.detections.length > 0) {
                    const detection = results.detections[0];
                    const box = detection.boundingBox;
                    
                    // Draw face box
                    if (this.ctx) {
                        this.ctx.save();
                        this.ctx.translate(this.ovr.width, 0);
                        this.ctx.scale(-1, 1);
                        
                        const x = box.xCenter * this.ovr.width;
                        const y = box.yCenter * this.ovr.height;
                        const w = box.width * this.ovr.width;
                        const h = box.height * this.ovr.height;
                        
                        this.ctx.strokeStyle = '#ff6600';
                        this.ctx.lineWidth = 2;
                        this.ctx.strokeRect(x - w/2, y - h/2, w, h);
                        
                        // Center dot
                        this.ctx.beginPath();
                        this.ctx.arc(x, y, 6, 0, Math.PI * 2);
                        this.ctx.fillStyle = '#ff6600';
                        this.ctx.fill();
                        
                        this.ctx.restore();
                    }
                    
                    // Calculate face position
                    const nx = -(box.xCenter - 0.5) * 2;
                    const ny = (box.yCenter - 0.5) * 2;
                    
                    this.face.x = nx * 180;
                    this.face.y = -ny * 140;
                    
                    // Depth from face size
                    const faceSize = Math.max(box.width, box.height);
                    this.face.z = Math.max(250, Math.min(800, 400 / Math.max(0.1, faceSize)));
                    
                    this.tracking = true;
                    $('trackDot').classList.add('on');
                    stat('sFace', 'YES', '#0f0');
                } else {
                    this.tracking = false;
                    $('trackDot').classList.remove('on');
                    stat('sFace', 'NO', '#f55');
                }
                
                stat('sX', this.face.x.toFixed(0));
                stat('sY', this.face.y.toFixed(0));
            }
            
            processNativeFaces(faces) {
                if (this.ctx) {
                    this.ctx.clearRect(0, 0, this.ovr.width, this.ovr.height);
                }
                
                if (faces.length > 0) {
                    const face = faces[0];
                    const box = face.boundingBox;
                    
                    // Draw
                    if (this.ctx) {
                        this.ctx.save();
                        this.ctx.translate(this.ovr.width, 0);
                        this.ctx.scale(-1, 1);
                        
                        this.ctx.strokeStyle = '#ff6600';
                        this.ctx.lineWidth = 2;
                        this.ctx.strokeRect(box.x, box.y, box.width, box.height);
                        
                        const cx = box.x + box.width/2;
                        const cy = box.y + box.height/2;
                        this.ctx.beginPath();
                        this.ctx.arc(cx, cy, 6, 0, Math.PI * 2);
                        this.ctx.fillStyle = '#ff6600';
                        this.ctx.fill();
                        
                        this.ctx.restore();
                    }
                    
                    const cx = (box.x + box.width/2) / this.vid.videoWidth;
                    const cy = (box.y + box.height/2) / this.vid.videoHeight;
                    
                    const nx = -(cx - 0.5) * 2;
                    const ny = (cy - 0.5) * 2;
                    
                    this.face.x = nx * 180;
                    this.face.y = -ny * 140;
                    
                    this.tracking = true;
                    $('trackDot').classList.add('on');
                    stat('sFace', 'YES', '#0f0');
                } else {
                    this.tracking = false;
                    $('trackDot').classList.remove('on');
                    stat('sFace', 'NO', '#f55');
                }
                
                stat('sX', this.face.x.toFixed(0));
                stat('sY', this.face.y.toFixed(0));
            }
            
            setupUI() {
                document.querySelectorAll('.ob').forEach(b => {
                    b.onclick = () => {
                        document.querySelectorAll('.ob').forEach(x => x.classList.remove('on'));
                        b.classList.add('on');
                        this.makeObj(b.dataset.o);
                    };
                });
                
                window.addEventListener('resize', () => {
                    this.camera.aspect = innerWidth / innerHeight;
                    this.camera.updateProjectionMatrix();
                    this.renderer.setSize(innerWidth, innerHeight);
                });
            }
            
            updateProjection() {
                this.smooth.x += (this.face.x - this.smooth.x) * 0.12;
                this.smooth.y += (this.face.y - this.smooth.y) * 0.12;
                this.smooth.z += (this.face.z - this.smooth.z) * 0.12;
                
                const { x, y, z } = this.smooth;
                const asp = innerWidth / innerHeight;
                const hw = 150, hh = hw / asp;
                const n = 10, f = 2500, r = n / z;
                
                this.camera.projectionMatrix.makePerspective(
                    (-hw - x) * r, (hw - x) * r,
                    (hh - y) * r, (-hh - y) * r,
                    n, f
                );
                this.camera.projectionMatrixInverse.copy(this.camera.projectionMatrix).invert();
                this.camera.position.set(x, y, z);
                this.camera.lookAt(x, y, 0);
            }
            
            animate() {
                requestAnimationFrame(() => this.animate());
                this.updateProjection();
                this.renderer.render(this.scene, this.camera);
            }
        }
        
        // START
        log('Page loaded');
        new App();
    })();
    </script>
</body>
</html>
